[{"name":"server.R","content":"#\r\n# This is the server logic of a Shiny web application. You can run the \r\n# application by clicking 'Run App' above.\r\n#\r\n# Find out more about building applications with Shiny here:\r\n# \r\n#    http://shiny.rstudio.com/\r\n#\r\n\r\n# Ok: what is the logic here? Have a problem and solution output. Within each, decide which chapter we are on, which section within the chapter, then output the correct problem/solution. To get the correct solution, the data needs to be independent of problem or solution...\r\n\r\nlibrary(shiny)\r\nlibrary(DT)\r\nlibrary(xtable) #to display table for c4 empirical\r\nR.utils::sourceDirectory(\"Problems\", onError=\"warning\", modifiedOnly=FALSE) # I needed the modifiedOnly to be false to get this to run properly...\r\nR.utils::sourceDirectory(\"Solutions\", onError=\"warning\", modifiedOnly=FALSE)\r\nR.utils::sourceDirectory(\"General Functions\", onError=\"warning\", modifiedOnly=FALSE)\r\noptions(width=120) #YES: this does what I want it to\r\n\r\n# Define server logic\r\nshinyServer(function(input, output) {\r\n  # Setting the problem number\r\n  probnum <- reactiveVal()\r\n  \r\n  observeEvent(input$manual_pnum, {\r\n    probnum(input$manual_pnum)\r\n  })\r\n  \r\n  observeEvent(input$newprob, {\r\n    rm(.Random.seed, envir=globalenv())#reset the seed... I'm not 100% sure what was going on, but due to using this value to set the seed, there was a loop occuring among the random values (in C7, alpha=0.01, p CIs). I think certain values looped back to their beginning. This creates a truly random starting place when the random button is hit next (literally erases the previous seed so that it isn't dependent on it and can't get wrapped in a loop with it).\r\n    npn <- sample(1:1000, size=1) #new problem number\r\n    probnum(npn)\r\n  })\r\n  \r\n  output$probnum <- renderText({\r\n    paste(\"Problem Number:\", probnum())\r\n  })\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  # Making the problem data (and situation)\r\n  probdat <- reactive({\r\n    # setting seed to the problem number\r\n    set.seed(probnum())\r\n    \r\n    # setting default output\r\n    stem <- \"This is filler stem text and data. This implies that information for this chapter has not been loaded/generated. The data below should be the integers 1 through 20 in ascending order.\"\r\n    data <- 1:20\r\n    \r\n    # doing specific generation for \r\n    if(input$ch == \"c1\"){\r\n      stem <- \"This is the stem for C1\"\r\n      data <- \"This is the data for C1\"\r\n      \r\n    } else if(input$ch == \"c2\"){\r\n      if(input$c2catcont==\"cont\"){\r\n        prob <- c2contp(n=input$c2n)\r\n        stem <- prob$stem\r\n        data <- hidden_data <- prob$data\r\n      } else { #if not continuous\r\n        prob <- c2catp(n=input$c2n)\r\n        stem <- prob$stem\r\n        data <- hidden_data <- prob$data\r\n      }\r\n      \r\n    } else if (input$ch == \"c3\"){\r\n      prob <- c3p(n=input$c3n)\r\n      stem <- prob$stem\r\n      data <- hidden_data <- prob$data\r\n      \r\n    } else if (input$ch == \"c4\"){\r\n      prob <- c4p(prob_type = input$c4_prob_type) #many more problem options that could be used, but I'm not going to worry about that right now... specifically options for different contexts/mediums, as well as sample size (Which fucks up some things...)\r\n      stem <- prob$stem\r\n      data <- prob$data\r\n      hidden_data <- prob$hidden_data\r\n    } else if (input$ch == \"c5\"){\r\n      prob <- c5p(prob_type = input$c5_prob_type)\r\n      stem <- prob$stem\r\n      data <- prob$data\r\n      hidden_data <- prob$hidden_data\r\n    } else if (input$ch == \"c6\"){\r\n      prob <- c6p(direction = input$c6dir, prob_type=input$c6type, n=input$c6n)\r\n      stem <- prob$stem\r\n      data <- prob$data\r\n      hidden_data <- prob$hidden_data\r\n      \r\n    } else if (input$ch == \"c7\"){ #need to figure out what to do for z, t, and p\r\n      prob <- c7p(prob_type = input$c7type, n=input$c7n, alpha=input$c7alpha)\r\n      stem <- prob$stem\r\n      data <- prob$data\r\n      hidden_data <- prob$hidden_data\r\n      \r\n    } else if (input$ch == \"c8\"){ #need to figure out what to do for z, t, and p\r\n      prob <- c8p(prob_type = input$c8type, n=input$c8n, direction=input$c8dir, alpha=input$c8alpha)\r\n      stem <- prob$stem\r\n      data <- prob$data\r\n      hidden_data <- prob$hidden_data\r\n      \r\n    }\r\n    \r\n    list(stem=stem, data=data, hidden_data=hidden_data)\r\n  })\r\n\r\n  \r\n  \r\n  \r\n  \r\n  output$problem <- renderUI({\r\n    stem <- probdat()$stem\r\n    dat <- probdat()$data\r\n    \r\n    if(input$ch == \"c4\" & !identical(dat, \"\")){ #do a few ifs for the different ones (most problems will go in the final \"else\")\r\n      colnames(dat) <- paste0(\"\\\\text{\", colnames(dat), \"}\") #cleaning column and rownames printing (so they don't render as math)\r\n      rownames(dat) <- paste0(\"\\\\text{\", rownames(dat), \"}\")\r\n      \r\n      xtab <- print(xtable(dat, align=rep(\"c\", ncol(dat)+1)), type=\"latex\", floating=FALSE, tabular.environment=\"array\", comment=FALSE, print.results=FALSE, sanitize.text.function = function(x){x}) #NEED that sanitize text function\r\n      mj_tab <- paste0(\"$$\", xtab, \"$$\")\r\n      list(\r\n        HTML(c(stem)),\r\n        withMathJax(HTML(mj_tab))\r\n        # HTML(html_tab) #if you print the xtable as html, this will print an ugly but usable table\r\n      )\r\n      \r\n    } else if (input$ch == \"c5\" & !identical(dat, \"\")) {\r\n      xtab <- print(xtable(dat, align=rep(\"c\", ncol(dat)+1)), type=\"latex\", floating=FALSE, tabular.environment=\"array\", comment=FALSE, print.results=FALSE, include.colnames = FALSE, sanitize.text.function = function(x){x}) #NEED that sanitize text function\r\n      mj_tab <- paste0(\"$$\", xtab, \"$$\")\r\n      list(\r\n        HTML(c(stem)),\r\n        withMathJax(HTML(mj_tab))\r\n      )\r\n      \r\n    } else { #if we don't need to display a table...\r\n      HTML(c(probdat()$stem, #either c or paste?\r\n             \"<br/>\",\"<br/>\",\r\n             paste(probdat()$data, collapse=\", \")))\r\n    }\r\n  })\r\n  \r\n  \r\n  # need to split answers by chapter, so output will need to be different (and rendering will need to be different).\r\n  # if(input$ch==\"c2\"){\r\n  #   if(input$c2catcont=='cont'){\r\n  #     output$c2fd <- renderDataTable({\r\n  #       \r\n  #     })\r\n  #   } else {\r\n  #     \r\n  #   }\r\n  # }\r\n  \r\n  output$solutiontext <- renderPrint({\r\n    dat  <- probdat()$data\r\n    hdat <- probdat()$hidden_data\r\n    out <- \"\" #default output\r\n    if(input$ch == \"c1\"){\r\n      \r\n    } else if(input$ch == \"c2\"){\r\n      if(input$c2catcont==\"cont\"){\r\n        out <- c2conts_all_text(dat, numclass = input$c2numclass)\r\n      } else { #if not continuous\r\n        out <- c2cats_all_text(dat)\r\n      }\r\n      \r\n    } else if (input$ch == \"c3\"){\r\n      out <- c3s_text(dat)\r\n      \r\n    } else if (input$ch == \"c4\"){\r\n      out <- c4s(probdat())\r\n      \r\n    } else if (input$ch == \"c5\"){\r\n      out <- c5s(probdat())\r\n    } else if (input$ch == \"c6\"){\r\n      out <- c6s_text(prob_type = hdat$prob_type, hdat=hdat)\r\n      \r\n    } else if (input$ch == \"c7\"){ #need to figure out what to do for z, t, and p (currently t)\r\n      out <- c7s_text(prob_type = hdat$prob_type, hdat=hdat)\r\n      \r\n    } else if (input$ch == \"c8\"){ #need to figure out what to do for z, t, and p (currently t)\r\n      out <- c8s_steps(prob_obj = probdat())\r\n    }\r\n    out\r\n  })\r\n  \r\n  output$solutionplot <- renderPlot({\r\n    dat  <- probdat()$data\r\n    hdat <- probdat()$hidden_data\r\n    if(input$ch == \"c1\"){\r\n      \r\n    } else if(input$ch == \"c2\"){\r\n      if(input$c2catcont==\"cont\"){\r\n        out <- c2conts_all_plots(dat, numclass = input$c2numclass)\r\n      } else { #if not continuous\r\n        out <- c2cats_all_plots(dat)\r\n      }\r\n      \r\n    } else if (input$ch == \"c3\"){\r\n      out <- c3s_plot(dat, outliers = input$c3bpo)\r\n      \r\n    } else if (input$ch == \"c4\"){\r\n      \r\n    } else if (input$ch == \"c5\"){\r\n      \r\n    } else if (input$ch == \"c6\"){\r\n      out <- c6s_plot(prob_type = hdat$prob_type, hdat=hdat)\r\n      \r\n    } else if (input$ch == \"c7\"){\r\n      out <- c7s_plot(prob_type = hdat$prob_type, hdat=hdat)\r\n      \r\n    } else if (input$ch == \"c8\"){\r\n      c8s_plot(prob_obj = probdat())\r\n      # c8s_plot(prob_type = hdat$prob_type, hdat=hdat)\r\n      # out <- cv_t_plot(direction = hdat$direction, alpha = hdat$alpha, df=length(hdat$dat) -1, tail_exp=1.1)\r\n    }\r\n  })\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  # as I only want to have 1 plot output device, I'm just using this \r\n  height <- reactive({\r\n    height <- 400\r\n    if(input$ch == \"c1\"){\r\n      \r\n    } else if(input$ch == \"c2\"){\r\n      if(input$c2catcont==\"cont\"){\r\n        height <- 400*6 # muliply by the number of plots being output to get each one to be at 400 height. CEX is currently (and should be) set to 1 (or larger) to make sure they render alright (numbers/labels not too small, etc)...\r\n      } else { #if not continuous\r\n        height <- 400*3\r\n      }\r\n      \r\n    } else if (input$ch == \"c3\"){ #don't change, as just one plot...\r\n      \r\n    } else if (input$ch == \"c4\"){\r\n      \r\n    } else if (input$ch == \"c5\"){\r\n      \r\n    } else if (input$ch == \"c6\"){\r\n      \r\n    } else if (input$ch == \"c7\"){\r\n      \r\n    } else if (input$ch == \"c8\"){\r\n      \r\n    }\r\n    height\r\n  })\r\n  \r\n  output$plotui <- renderUI({\r\n    plotOutput(\"solutionplot\", height = height())\r\n  })\r\n})\r\n","type":"text"},{"name":"ui.R","content":"#\r\n# This is the user-interface definition of a Shiny web application. You can\r\n# run the application by clicking 'Run App' above.\r\n#\r\n# Find out more about building applications with Shiny here:\r\n# \r\n#    http://shiny.rstudio.com/\r\n#\r\n\r\nlibrary(shiny)\r\nlibrary(DT)\r\nlibrary(xtable) #to display table for c4 empirical\r\nR.utils::sourceDirectory(\"Problems\", onError=\"warning\", modifiedOnly=FALSE)\r\nR.utils::sourceDirectory(\"Solutions\", onError=\"warning\", modifiedOnly=FALSE)\r\nR.utils::sourceDirectory(\"General Functions\", onError=\"warning\", modifiedOnly=FALSE)\r\n\r\n# Define UI for application that draws a histogram\r\nshinyUI(fluidPage(\r\n  \r\n  # Application title\r\n  titlePanel(\"Basic Stats Homework App\"),\r\n  \r\n  # Sidebar\r\n  sidebarLayout(\r\n    sidebarPanel(\r\n      # Problem numbers\r\n       h3(textOutput(\"probnum\")),\r\n       h5(\"Below, you may generate a random new problem, or go to a specific problem.\"),\r\n       actionButton(\"newprob\", \"Random New Problem\"),\r\n       numericInput(\"manual_pnum\", \"Go to this problem:\", value = 1),\r\n       \r\n       # Chapter Selection\r\n       selectInput(\"ch\",\r\n                   \"Which chapter?\",\r\n                   choices = list(#\"Chapter 1\" = \"c1\",\r\n                                  \"Chapter 2\" = \"c2\", \r\n                                  \"Chapter 3\" = \"c3\",\r\n                                  \"Chapter 4\" = \"c4\", \r\n                                  \"Chapter 5\" = \"c5\",\r\n                                  \"Chapter 6\" = \"c6\",\r\n                                  \"Chapter 7\" = \"c7\",\r\n                                  \"Chapter 8\" = \"c8\"\r\n                                  ),\r\n                  selected=\"c2\"),\r\n       \r\n       # Chapter Options\r\n       conditionalPanel(\r\n         condition = \"input.ch == 'c2'\",\r\n         h3(\"Chapter 2 Options\"),\r\n         selectInput(\"c2catcont\", \"Categorical or Continuous?\",\r\n                     list(\"Categorical\" = \"cat\", \r\n                          \"Continuous\" = \"cont\"), selected = \"cont\"),\r\n         sliderInput(\"c2n\", \"Sample Size\", min=9, max=30, value = 15),\r\n         sliderInput(\"c2numclass\", \"Number of Classes (for continuous)\", min=5, max=10, value=7)\r\n       ),\r\n       \r\n       conditionalPanel(\r\n         condition = \"input.ch == 'c3'\",\r\n         h3(\"Chapter 3 Options\"),\r\n         sliderInput(\"c3n\", \"Sample Size\", min=7, max=20, value = 15),\r\n         checkboxInput(\"c3bpo\", \"Plot Outliers in Boxplot?\", value = FALSE)\r\n       ),\r\n       \r\n       conditionalPanel(\r\n         condition = \"input.ch == 'c4'\",\r\n         h3(\"Chapter 4 Options\"),\r\n         # sliderInput(\"c4n\", \"Sample Size (when appropriate)\", min=2, max=4, value = 3), #maybe make the value null by default? Meh, this option just doesn't really work well with these problems......\r\n        selectInput(\"c4_prob_type\", \"Type of Question\", list(\"Random\"=\"random\",\r\n                                                             \"Basic Probability\" = \"basic_prob\",\r\n                                                             \"Basic Complement\" = \"basic_comp\",\r\n                                                             \"Advanced Complement\" = \"adv_comp\",\r\n                                                             \"Or (with Mutually Exclusive)\" = \"or_wme\",\r\n                                                             \"Or (without Mutually Exclusive)\" = \"or_wome\",\r\n                                                             \"Conditional Probability\" = \"cond\",\r\n                                                             \"And (with Replacement)\" = \"and_wr\",\r\n                                                             \"And (without Replacement)\" = \"and_wor\",\r\n                                                             \"Fundamental Counting Rule\" = \"fcr\",\r\n                                                             \"Ways to Arrange\" = \"arrange\",\r\n                                                             \"Permutations\" = \"perm\",\r\n                                                             \"Combinations\" = \"combn\"))\r\n        # selectInput(\"c4card_opts\", \"Playing Card Options\", list(\"Random\" = \"random\",\r\n        #                                                         \"Card Values\" = \"value\",\r\n        #                                                         \"Card Suits\" = \"suit\"))\r\n        # selectInput(\"c4context_opts\", \"Problem Contexts\", list(\"Random\" = \"random\",\r\n        #                                                         \"Card Values\" = \"value\",\r\n        #                                                         \"Card Suits\" = \"suit\"))# lists are different for every problem context/medium, AND (at least within the other group) are different than EACH OTHER, and I don't want to go through each... I guess I could make a second conditional panel under this to display when the particular thing is selected in select input, then make a different options variable for each one (just in case). But, I'm not going to right now...\r\n        \r\n       ),\r\n       \r\n       conditionalPanel(\r\n         condition = \"input.ch == 'c5'\",\r\n         h3(\"Chapter 5 Options\"),\r\n         selectInput(\"c5_prob_type\", \"Type of Question\", list(\"Random\"=\"random\",\r\n                                                              \"Discrete\" = \"discrete\",\r\n                                                              \"Expected Value\" = \"expect\",\r\n                                                              \"Binomial: Single Event\" = \"sebin\",\r\n                                                              \"Binomial: Mean, Var, SD\" = \"binomial\"))\r\n\r\n       ),\r\n       \r\n       conditionalPanel(\r\n         condition = \"input.ch == 'c6'\",\r\n         h3(\"Chapter 6 Options\"),\r\n         sliderInput(\"c6n\", \"Sample Size (when appropriate)\", min=7, max=20, value = 15),\r\n         selectInput(\"c6dir\", \"Direction of Question\", list(\"Random\" = \"random\",\r\n                                                               \"Greater Than\" = \"greater than\",\r\n                                                               \"Less Than\" = \"less than\")), \r\n         selectInput(\"c6type\", \"Type of Question\", list(\"Random\"=\"random\",\r\n                                                        \"Z to Probability (basic)\" = \"z2p\",\r\n                                                        \"Z to Probability (word)\" = \"z2p_word\",\r\n                                                        \"Probability to Value\" = \"p2v\",\r\n                                                        \"Z to Probability (sample/clt)\" = \"z2p_samp\"))\r\n       ),\r\n       \r\n       conditionalPanel(\r\n         condition = \"input.ch == 'c7'\",\r\n         h3(\"Chapter 7 Options\"),\r\n         sliderInput(\"c7n\", \"Sample Size\", min=7, max=20, value = 15),\r\n         selectInput(\"c7alpha\", \"Alpha Level\", list(\"Random\" = \"random\",\r\n                                                    \".01\"=.01,\r\n                                                    \".05\"=.05,\r\n                                                    \".10\"=.10,\r\n                                                    \".20\"=.20)), \r\n         selectInput(\"c7type\", \"Type of Question\", list(\"Random\" = \"random\",\r\n                                                        \"Z CI\" = \"z\",\r\n                                                        \"T CI\" = \"t\",\r\n                                                        \"P CI\" = \"p\"))\r\n       ),\r\n       \r\n       conditionalPanel(\r\n         condition = \"input.ch == 'c8'\",\r\n         h3(\"Chapter 8 Options\"),\r\n         sliderInput(\"c8n\", \"Sample Size\", min=7, max=20, value = 15),\r\n         selectInput(\"c8type\", \"Problem Type\", list(\"Random\" = \"random\",\r\n                                                    \"Z Test\" = \"ztest\",\r\n                                                    \"T Test\" = \"ttest\",\r\n                                                    \"P Test\" = \"ptest\")),\r\n         selectInput(\"c8dir\", \"Direction of Alternative\", list(\"Random\" = \"random\",\r\n                                                        \"Greater Than\" = \"greater than\",\r\n                                                        \"Less Than\" = \"less than\",\r\n                                                        \"Not Equal To\" = \"not equal to\")),\r\n         selectInput(\"c8alpha\", \"Alpha Level\", list(\"Random\" = \"random\",\r\n                                                    \".01\"=.01,\r\n                                                    \".05\"=.05,\r\n                                                    \".10\"=.10))\r\n       )\r\n       \r\n       #conditionalPanel().... #for the rest of the chapters' options\r\n    ),\r\n    \r\n\r\n    \r\n    # Show a plot of the generated distribution\r\n    mainPanel(\r\n       tabsetPanel(type=\"tabs\",\r\n                   tabPanel(\"Problem\", \r\n                            uiOutput(\"problem\")),\r\n                   tabPanel(\"Solutions\",\r\n                            verbatimTextOutput(\"solutiontext\"),\r\n                            tags$head(tags$style(\"#solutiontext{min-width: 800px}\")), #lots of HTML options available. The hashtag tells it what to apply these options to. This min width makes sure that the size of the output is at least what is needed to display the table nicely (at least for now). The width option in the server file, OUTSIDE of the render function, is what sets where the R code wraps in the first place (this was a pain and wasn't working when inside of the solutiontext render function).\r\n                            uiOutput(\"plotui\")))\r\n    )\r\n  )\r\n))\r\n","type":"text"},{"name":"General Functions/cards.r","content":"deck_of_cards <- data.frame(suit = rep(c(\"spades\", \"hearts\", \"diamonds\", \"clubs\"), 13),\r\n                            value = rep(c(2:10, \"jack\", \"queen\", \"king\", \"ace\"), each=4))\r\ndeck_of_cards <- data.frame(deck_of_cards, card = paste(deck_of_cards$value, \"of\", deck_of_cards$suit))\r\ndeck_of_cards","type":"text"},{"name":"General Functions/fr.r","content":"fr <- function(x, dig=4){\r\n  format(round(x, digits = dig), nsmall = dig, scientific = F)\r\n}","type":"text"},{"name":"General Functions/run_dup_tally.r","content":"run_dup_tally <- function(x){ #running duplicate tally\r\n  out <- numeric(length=length(x))\r\n  out[1] <- 1\r\n  for(i in 2:length(x))\r\n    out[i] <- sum(x[i] == x[1:i])\r\n  out\r\n}","type":"text"},{"name":"Homework.Rproj","content":"Version: 1.0\r\n\r\nRestoreWorkspace: Default\r\nSaveWorkspace: Default\r\nAlwaysSaveHistory: Default\r\n\r\nEnableCodeIndexing: Yes\r\nUseSpacesForTab: Yes\r\nNumSpacesForTab: 2\r\nEncoding: UTF-8\r\n\r\nRnwWeave: Sweave\r\nLaTeX: pdfLaTeX\r\n","type":"text"},{"name":"Problems/chapter 2 problems.R","content":"# Header ----\r\n# Notes: \r\n# Improvement ideas: eventually, consider generating data using a variety of different stems for different problems?\r\n# Continuous ----\r\nsysbpdg <- function(n){sample(80:120, size=n, replace=TRUE)} #Systolic Blood Pressure\r\nagedg <- function(n){sample(18:38, size=n, replace=TRUE)} #olympic athletes\r\nweightdg <- function(n){sample(60:100, size=n, replace=TRUE)} #kilograms\r\nheightdg <- function(n){sample(157:193, size=n, replace=TRUE)} #centimeters\r\n\r\nc2cont_randdg <- function(n){\r\n  dat <- list(sysbpdg(n), agedg(n), weightdg(n), heightdg(n))\r\n  ds <- sample(1:length(dat), size=1)\r\n  dat[[ds]]\r\n}\r\n\r\nc2contp <- function(n=NULL){\r\n  if(is.null(n))\r\n    n <- sample(15:25, size=1)\r\n  stem <- \"Consider the data below on systolic blood pressure, age, weight, or height. Using this data, you may calculate the upper and lower class boundaries and class limits, frequencies, relative frequencies (in fractional, reduced, and/or decimal forms), percentages, cumulative frequencies, and midpoints. Using this information, you can graph frequency histograms, relative frequency histograms, frequency polygons, relative frequency polygons, ogives, and stem-and-leaf plots.\"\r\n  data <- c2cont_randdg(n)\r\n  list(stem=stem, data=data)\r\n}\r\n\r\n\r\n\r\n# Categorical ----\r\nbtdg <- function(n){sample(c(\"A\",\"B\",\"AB\",\"O\"), size=n, replace = TRUE)} # blood type\r\nhcdg <- function(n){sample(c(\"Yellow\", \"Brown\", \"Black\", \"Red\"), size=n, replace = TRUE)} # hair color\r\nposdg <- function(n){sample(c(\"Gold\", \"Silver\", \"Bronze\"), size=n, replace = TRUE)} # medals\r\nracedg <- function(n){sample(c(\"White\", \"Black\", \"Hispanic\", \"Asian\"), size=n, replace = TRUE)} # race\r\ngradedg <- function(n){sample(c(\"A\", \"B\", \"C\", \"D\", \"F\"), size=n, replace = TRUE)}\r\n\r\nc2cat_randdg <- function(n){\r\n  dat <- list(btdg(n), hcdg(n), posdg(n), racedg(n), gradedg(n))\r\n  ds <- sample(1:length(dat), size=1)\r\n  dat[[ds]]\r\n}\r\n\r\nc2catp <- function(n=NULL){\r\n  if(is.null(n))\r\n    n <- sample(15:25, size=1)\r\n  stem <- \"Consider the data below on blood types, hair colors, medals, races, or grades. Using this data, you may calculate the frequencies, relative frequencies (in fractional, reduced, and/or decimal forms), percentages, and midpoints. Using this information, you can graph bar charts, pareto charts, and pie charts.\"\r\n  data <- c2cat_randdg(n)\r\n  list(stem=stem, data=data)\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","type":"text"},{"name":"Problems/chapter 3 problems.R","content":"# Header ----\r\n# Notes: \r\n# Improvement ideas: eventually, consider generating data using a variety of different stems for different problems?\r\n# Continuous ----\r\nsysbpdg <- function(n){sample(80:120, size=n, replace=TRUE)} #Systolic Blood Pressure\r\nagedg <- function(n){sample(18:38, size=n, replace=TRUE)} #olympic athletes\r\nweightdg <- function(n){sample(60:100, size=n, replace=TRUE)} #kilograms\r\nheightdg <- function(n){sample(157:193, size=n, replace=TRUE)} #centimeters\r\n\r\nc3randdg <- function(n){\r\n  ds <- sample(1:4, size=1)\r\n  dat <- list(sysbpdg(n), agedg(n), weightdg(n), heightdg(n))\r\n  dat[[ds]]\r\n}\r\n\r\nc3p <- function(n=NULL){\r\n  if(is.null(n))\r\n    n <- sample(9:15, size=1) # dont think this is neeeded: shiny will give default values anyways...\r\n  stem <- \"Consider the data below on systolic blood pressure, age, weight, or height. Using this data, you may calculate the mean, median, mode, midrange, range, population variance, population standard deviation, sample variance, sample standard deviation, percentiles, deciles, quartiles, the inter-quartile range, outliers, and boxplots.\"\r\n  data <- c3randdg(n)\r\n  list(stem=stem, data=data)\r\n}\r\n","type":"text"},{"name":"Problems/chapter 4 problems.R","content":"# Header ----\r\n# Description: There are a TON of types of problems for this chapter, especially if I utilize multiple mediums (the goal). I'll start with a single medium, work all of the problems (and all of the solutions) then move on to the next one. Below is a list of problem types and mediums that should be covered.\r\n# Problem Types: Basic, Basic Compliment, Advanced Compliment, And with Replacement, And without Replacement, Or with Mutually Exclusive, Or without Mutually Exclusive, Conditional, and then counting rules\r\n# Mediums (or context): Cards in a Deck, Balls in an Urn, Coins (when appropriate), Die (when appropriate), Empirical\r\n\r\n\r\n# Actually, lets make a matrix of when things are appropriate:\r\napprop <- structure(c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, \r\n                      TRUE, TRUE, TRUE, TRUE, TRUE, NA, TRUE, TRUE, TRUE, TRUE, TRUE, \r\n                      NA, NA, NA, NA, TRUE, TRUE, TRUE, TRUE, NA, TRUE, NA, NA, TRUE, \r\n                      TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE), .Dim = c(8L, 5L), .Dimnames = list(\r\n                        c(\"Basic\", \"Basic Complement\", \"Advanced Complement\", \"And w/ Rep\", \r\n                          \"And w/o Rep\", \"Or w/ ME\", \"Or w/o ME\", \"Conditional\"), c(\"Cards\", \r\n                                                                                    \"Balls\", \"Coins\", \"Die\", \"Empirical\")))\r\n\r\n# Cards ----\r\n# source(\"General Functions/cards.r\")\r\n# source(\"General Functions/fr.r\")\r\n# source(\"General Functions/run_dup_tally.r\")\r\n## Basic Probability ----\r\nc4p_cards_basic <- function(type=\"random\"){\r\n  if(type==\"random\")\r\n    type <- sample(c(\"suit\", \"value\"), size=1)\r\n  if(!(type==\"suit\" | type==\"value\"))\r\n    stop(\"type must be random, suit, or value.\")\r\n  \r\n  id <- as.character(sample(deck_of_cards[[type]], 1))\r\n  id_stem <- id\r\n  if(type==\"suit\")\r\n    id_stem <- substr(id, start=1, stop=nchar(id)-1)\r\n  stem <- paste0(\"If a single card is drawn, find the probability that a card is a \", id_stem, \".\")\r\n  \r\n  list(stem=stem,\r\n       data=\"\",\r\n       hidden_data=list(type=type,\r\n                        id=id))\r\n}\r\n\r\n## Basic Complement ----\r\nc4p_cards_bascomp <- function(type=\"random\"){\r\n  if(type==\"random\")\r\n    type <- sample(c(\"suit\", \"value\"), size=1)\r\n  if(!(type==\"suit\" | type==\"value\"))\r\n    stop(\"type must be random, suit, or value.\")\r\n  \r\n  id <- as.character(sample(deck_of_cards[[type]], 1))\r\n  id_stem <- id\r\n  if(type==\"suit\")\r\n    id_stem <- substr(id, start=1, stop=nchar(id)-1)\r\n  stem <- paste0(\"If a single card is drawn, find the probability that a card is not a \", id_stem, \".\")\r\n  \r\n  list(stem=stem,\r\n       data=\"\",\r\n       hidden_data=list(type=type,\r\n                        id=id))\r\n}\r\n\r\n## Advanced Complement ----\r\nc4p_cards_advcomp <- function(type=\"random\", n=NULL){\r\n  if(type==\"random\")\r\n    type <- sample(c(\"suit\", \"value\"), size=1)\r\n  if(!(type==\"suit\" | type==\"value\"))\r\n    stop(\"type must be random, suit, or value.\")\r\n  if(is.null(n))\r\n    n <- sample(2:5, 1)\r\n\r\n  id <- as.character(sample(deck_of_cards[[type]], 1))\r\n  id_stem <- id\r\n  if(type==\"suit\")\r\n    id_stem <- substr(id, start=1, stop=nchar(id)-1)\r\n  stem <- paste0(\"If \", n, \" cards are drawn without replacement, find the probability that least one \", id_stem, \" is drawn.\")\r\n\r\n  list(stem=stem,\r\n       data=\"\",\r\n       hidden_data=list(type=type,\r\n                        id=id,\r\n                        n=n))\r\n}\r\n\r\n## And (with replacement) ----\r\nc4p_cards_and_wr <- function(type=\"random\", n=NULL){\r\n  if(type==\"random\")\r\n    type <- sample(c(\"suit\", \"value\"), size=1)\r\n  if(!(type==\"suit\" | type==\"value\"))\r\n    stop(\"type must be random, suit, or value.\")\r\n  if(is.null(n))\r\n    n <- sample(2:4, 1)\r\n  \r\n  id <- as.character(sample(deck_of_cards[[type]], n))\r\n  id_stem <- id\r\n  if(type==\"suit\")\r\n    id_stem <- substr(id, start=1, stop=nchar(id)-1)\r\n  stem <- paste0(\"If \", n, \" cards are drawn with replacement, find the probability of drawing the following: \", paste(id_stem, collapse=\", then a \"), \" (i.e., P(\",paste0(id_stem, collapse=\",\"),\"))\")\r\n  \r\n  list(stem=stem,\r\n       data=\"\",\r\n       hidden_data=list(type=type,\r\n                        id=id,\r\n                        n=n))\r\n}\r\n\r\n## And (without replacement) ----\r\nc4p_cards_and_wor <- function(type=\"random\", n=NULL){\r\n  if(type==\"random\")\r\n    type <- sample(c(\"suit\", \"value\"), size=1)\r\n  if(!(type==\"suit\" | type==\"value\"))\r\n    stop(\"type must be random, suit, or value.\")\r\n  if(is.null(n))\r\n    n <- sample(2:4, 1)\r\n  \r\n  id <- as.character(sample(deck_of_cards[[type]], n))\r\n  id_stem <- id\r\n  if(type==\"suit\")\r\n    id_stem <- substr(id, start=1, stop=nchar(id)-1)\r\n  stem <- paste0(\"If \", n, \" cards are drawn without replacement, find the probability of drawing the following: \", paste(id_stem, collapse=\", then a \"), \" (i.e., P(\",paste0(id_stem, collapse=\",\"),\"))\")\r\n  \r\n  list(stem=stem,\r\n       data=\"\",\r\n       hidden_data=list(type=type,\r\n                        id=id,\r\n                        n=n))\r\n}\r\n\r\n## Or (with ME) ----\r\nc4p_cards_or_wme <- function(type=\"random\"){\r\n  if(type==\"random\")\r\n    type <- sample(c(\"suit\", \"value\"), size=1)\r\n  if(!(type==\"suit\" | type==\"value\"))\r\n    stop(\"type must be random, suit, or value.\")\r\n  \r\n  id <- as.character(sample(unique(deck_of_cards[[type]]), 2))\r\n  id_stem <- id\r\n  if(type==\"suit\")\r\n    id_stem <- substr(id, start=1, stop=nchar(id)-1)\r\n  stem <- paste0(\"If a single card is drawn, find the probability of drawing a \", paste(id_stem, collapse=\" or a \"), \" (i.e., P(\",paste0(id_stem, collapse=\" or \"),\"))\")\r\n  \r\n  list(stem=stem,\r\n       data=\"\",\r\n       hidden_data=list(type=type,\r\n                        id=id))\r\n}\r\n\r\n## Or (without ME) ----\r\nc4p_cards_or_wome <- function(){\r\n  type <- c(\"value\", \"suit\")\r\n  id <- as.character(c(sample(unique(deck_of_cards[[type[1]]]), 1), sample(unique(deck_of_cards[[type[2]]]), 1)))\r\n  id_stem <- id\r\n  id_stem[2] <- substr(id[2], start=1, stop=nchar(id[2])-1)\r\n  stem <- paste0(\"If a single card is drawn, find the probability of drawing a \", paste(id_stem, collapse=\" or a \"), \" (i.e., P(\",paste0(id_stem, collapse=\" or \"),\"))\")\r\n  \r\n  list(stem=stem,\r\n       data=\"\",\r\n       hidden_data=list(type=type,\r\n                        id=id))\r\n}\r\n\r\n## Card Problem Function ----\r\nc4p_cards <- function(card_prob_type=\"random\", n=NULL, card_opts=\"random\"){\r\n  cds <- sample(1:7, size=1) #7 types of card problems: pick one.\r\n  card_prob_names <- c(\"basic_prob\", \"basic_comp\", \"adv_comp\", \"and_wr\", \"and_wor\", \"or_wme\", \"or_wome\")\r\n  if(card_prob_type==\"random\"){\r\n    cpn <- card_prob_names[cds] #card, so start with c (so this doesn't get confused later on...)\r\n  } else {\r\n    if(!(card_prob_type %in% card_prob_names))\r\n      stop(paste0(\"There are not currently card problems of that type. Card problems must be one of the following: random, \", paste0(card_prob_names, collapse=\", \")))\r\n    cpn <- card_prob_type\r\n  }\r\n  \r\n  if(cpn == \"basic_prob\"){\r\n    out <- c4p_cards_basic(type=card_opts)\r\n  } else if (cpn == \"basic_comp\"){\r\n    out <- c4p_cards_bascomp(type=card_opts)\r\n  } else if (cpn == \"adv_comp\"){\r\n    out <- c4p_cards_advcomp(type=card_opts, n=n)\r\n  } else if (cpn == \"and_wr\"){\r\n    out <- c4p_cards_and_wr(type=card_opts, n=n)\r\n  } else if (cpn == \"and_wor\"){\r\n    out <- c4p_cards_and_wor(type=card_opts, n=n)\r\n  } else if (cpn == \"or_wme\"){\r\n    out <- c4p_cards_or_wme(type=card_opts)\r\n  } else if (cpn == \"or_wome\"){\r\n    out <- c4p_cards_or_wome() #no choice here: needs both suit and value...\r\n  }\r\n  out$hidden_data$card_prob_type <- cpn\r\n  out\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Empirical ----\r\n# Start with conditional probability, then move on.\r\nc4p_empirical_cond <- function(){\r\n  # can change these for context...\r\n  context <- sample(c(\"medicine\", \"business\"), 1)\r\n  \r\n  if (context==\"medicine\"){\r\n    cn <- c(\"Nurse\", \"Doctor\")\r\n    rn <- c(\"ER\", \"Family Practice\")\r\n  } else {\r\n    cn <- c(\"Windows user\", \"Mac user\")\r\n    rn <- c(\"Sales\", \"Accounting\")\r\n  }\r\n  \r\n  tab <- matrix(sample(1:100, size=4, replace=TRUE), ncol=2)\r\n  rownames(tab) <- rn\r\n  colnames(tab) <- cn\r\n  \r\n  wr <- sample(1:2, 1) #which row\r\n  wc <- sample(1:2, 1) #which column\r\n  wg <- sample(c(\"r\", \"c\"), 1) #which is given\r\n  \r\n  if(wg==\"r\"){\r\n    stem <- paste0(\"Using the data below, find the probability than an individual is a \", cn[wc],\", given that they work in the \", rn[wr], \" department.\")\r\n  } else {\r\n    stem <- paste0(\"Using the data below, find the probability than an individual works in the \", rn[wr],\" department, given that they are a \", cn[wc], \".\")\r\n  }\r\n  \r\n  list(stem=stem,\r\n       data=tab,\r\n       hidden_data=list(wr=wr,\r\n                        wc=wc,\r\n                        wg=wg))\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Other ----\r\n# These problems will not have any particular context associated with them...\r\n## Arranging ----\r\nc4p_other_arrange <- function(context=\"random\", n=NULL){\r\n  context_options <- c(\"none\", \"race\", \"paper\", \"guests\")\r\n  if(context==\"random\")\r\n    context <- sample(context_options, size=1)\r\n  if(!(context %in% context_options))\r\n    stop(paste0(\"context must be one of the following: \", paste0(context_options, collapse=\", \")))\r\n  \r\n  if(is.null(n))\r\n    n <- sample(3:12, size = 1)\r\n  \r\n  if(context==\"none\"){\r\n    stem <- paste0(\"Calculate how many unique ways you can arrange \", n, \" objects.\")\r\n  } else if (context==\"race\") {\r\n    stem <- paste0(\"If \", n, \" runners are participating in a race, determine the number of unique ways they can finish.\")\r\n  } else if (context==\"paper\") {\r\n    stem <- paste0(\"A professor just dropped all their notes on the ground! If they had \", n, \" pieces of paper and picked them up at random, determine the number of arrangements the papers could be in now.\")\r\n  } else if (context==\"guests\") {\r\n    stem <- paste0(\"A clinic just had \", n, \" clients check in online at the exact same time, and need to determine what order to see them. Determine how many unique orders they could see the clients in.\")\r\n  }  else {stop(\"context error in c4p_other_arrange\")}\r\n  \r\n  list(stem=stem,\r\n       data=\"\",\r\n       hidden_data=list(n=n))\r\n}\r\n\r\n## Sample Space (fundamental counting rule) ----\r\nc4p_other_fcr <- function(n=NULL){\r\n  if(is.null(n))\r\n    n <- sample(2:5, size = 1)\r\n  \r\n  die_faces <- sample((2:10)*2, size=n, replace = TRUE)\r\n  \r\n  stem <- paste0(\"Consider a case where you are 'rolling' \", n, \" die with different numbers of faces (\", paste0(die_faces, collapse=\", \"), \") and observing the outcome. How many different outcomes are possible (i.e., what is the size of the sample space)?\")\r\n  \r\n  list(stem=stem,\r\n       data=\"\",\r\n       hidden_data=list(die_faces=die_faces))\r\n}\r\n\r\n## Combination ----\r\nc4p_other_combn <- function(context=\"random\", n=NULL){\r\n  context_options <- c(\"none\", \"surf\", \"work\", \"class\")\r\n  if(context==\"random\")\r\n    context <- sample(context_options, size=1)\r\n  if(!(context %in% context_options))\r\n    stop(paste0(\"context must be one of the following: \", paste0(context_options, collapse=\", \")))\r\n  \r\n  if(is.null(n))\r\n    n <- sample(10:100, size = 1)\r\n  r <- sample(2:10, size=1)\r\n  \r\n  if(context==\"none\"){\r\n    stem <- paste0(\"Calculate how many ways you can choose \", r,\" objects from \", n, \" total objects, if order doesn't matter.\")\r\n  } else if (context==\"surf\") {\r\n    stem <- paste0(\"In a recent local surfing competition, the top \", r,\" surfers are automatically bumped up to the next level (nationals). If \", n, \" total surfers entered the competition, how many different ways can the winners be selected?\")\r\n  } else if (context==\"work\") {\r\n    stem <- paste0(\"A local business is selecting the top \", r,\" individuals from sales for a week long cruise. If \", n, \" total individuals work in the sales department, how many different ways can the winners be selected?\")\r\n  } else if (context==\"class\") {\r\n    stem <- paste0(\"We are selecting \", r,\" individuals from your year to serve as your 'class council' (for reunions and such). If \", n, \" total individuals are in your class, how many different ways can the council be selected?\")\r\n  }\r\n  \r\n  list(stem=stem,\r\n       data=\"\",\r\n       hidden_data=list(r=r,\r\n                        n=n))\r\n}\r\n\r\n## Permutation ----\r\nc4p_other_perm <- function(context=\"random\", n=NULL){\r\n  context_options <- c(\"none\", \"surf\", \"work\", \"class\")\r\n  if(context==\"random\")\r\n    context <- sample(context_options, size=1)\r\n  if(!(context %in% context_options))\r\n    stop(paste0(\"context must be one of the following: \", paste0(context_options, collapse=\", \")))\r\n  \r\n  if(is.null(n))\r\n    n <- sample(10:100, size = 1)\r\n  r <- sample(2:10, size=1)\r\n  \r\n  if(context==\"none\"){\r\n    stem <- paste0(\"Calculate how many ways you can choose \", r,\" objects from \", n, \" total objects, if order matters.\")\r\n  } else if (context==\"surf\") {\r\n    stem <- paste0(\"In a recent local surfing competition, the top \", r,\" surfers are automatically bumped up to the next level (professional), with the top placed surfer getting placed in the top tier pro circuit, the second placed getting the second tier pro circuit, etc. If \", n, \" total surfers entered the competition, how many different ways can the winners be selected?\")\r\n  } else if (context==\"work\") {\r\n    stem <- paste0(\"A local business is handing out prizes to the top \", r,\" individuals from their sales department! The top individual will be given $1000, the second individual will be given $900, and so on. If \", n, \" total individuals work in the sales department, how many different ways can the winners be selected?\")\r\n  } else if (context==\"class\") {\r\n    stem <- paste0(\"We are selecting \", r,\" individuals from your year to serve as your 'class government officials'. The person with the most votes will serve as 'president', while the person with the second most votes will be 'vice president', and so forth. If \", n, \" total individuals are in your class, how many different ways can the government officials be selected?\")\r\n  }\r\n  \r\n  list(stem=stem,\r\n       data=\"\",\r\n       hidden_data=list(r=r,\r\n                        n=n))\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Complete Problem Function ----\r\nc4p <- function(prob_type=\"random\", n=NULL, card_opts=\"random\", context=\"random\"){\r\n  prob_names <- c(\"basic_prob\", \"basic_comp\", \"adv_comp\", \"and_wr\", \"and_wor\", \"or_wme\", \"or_wome\", \"cond\", \"arrange\", \"fcr\", \"combn\", \"perm\")\r\n  ds <- sample(1:length(prob_names), size=1) #pick one type of problem, for if it is random\r\n  if(prob_type==\"random\"){\r\n    pn <- prob_names[ds] \r\n  } else {\r\n    if(!(prob_type %in% prob_names))\r\n      stop(paste0(\"There are not currently problems of that type. Problems must be one of the following: random, \", paste0(prob_names, collapse=\", \")))\r\n    pn <- prob_type\r\n  }\r\n  \r\n  if(pn == \"basic_prob\"){\r\n    out <- c4p_cards_basic(type=card_opts)\r\n  } else if (pn == \"basic_comp\"){\r\n    out <- c4p_cards_bascomp(type=card_opts)\r\n  } else if (pn == \"adv_comp\"){\r\n    out <- c4p_cards_advcomp(type=card_opts, n=n)\r\n  } else if (pn == \"and_wr\"){\r\n    out <- c4p_cards_and_wr(type=card_opts, n=n)\r\n  } else if (pn == \"and_wor\"){\r\n    out <- c4p_cards_and_wor(type=card_opts, n=n)\r\n  } else if (pn == \"or_wme\"){\r\n    out <- c4p_cards_or_wme(type=card_opts)\r\n  } else if (pn == \"or_wome\"){\r\n    out <- c4p_cards_or_wome() #no choice here: needs both suit and value...\r\n  } else if (pn == \"cond\"){\r\n    out <- c4p_empirical_cond()\r\n  } else if (pn == \"arrange\"){\r\n    out <- c4p_other_arrange(context=context, n=n)\r\n  } else if (pn == \"fcr\"){\r\n    out <- c4p_other_fcr(n=n)\r\n  } else if (pn == \"combn\"){\r\n    out <- c4p_other_combn(context=context, n=n)\r\n  } else if (pn == \"perm\"){\r\n    out <- c4p_other_perm(context=context, n=n)\r\n  } else {\r\n    stop(\"Problem type currently not supported in c4p.\")\r\n  }\r\n  out$hidden_data$prob_type <- pn\r\n  out\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","type":"text"},{"name":"Problems/chapter 5 problems.R","content":"# Problem types: \r\n# - discrete: mean, var, sd (could all be same problem, like in chapter 3)\r\n# - expected value (just do 1 table at a time)\r\n# - binomial: probability of a single event\r\n# - binomial: mean, var, sd of binomial dist (all be same prob, like in c3)\r\n\r\nsource(\"General Functions/fr.r\")\r\n\r\n# Discrete ----\r\nc5p_discrete <- function(){\r\n  nm1 <- sample(2:4,1)\r\n  p <- diff(c(0,sort(runif(nm1, 0, 1)), 1)) #this will add another point, making total length of n\r\n  p <- round(p,2)\r\n  p[nm1+1] <- 1-sum(p[1:nm1]) #addresses any rounding errors, making sure this adds to 1 every time...\r\n  \r\n  x <- 0:nm1\r\n  tab <- data.frame(px=p, x=x) #the one for me to work with\r\n  \r\n  ptab <- t(tab) #the one to display nicely\r\n  rownames(ptab) <- c(\"P(X)\", \"X\")\r\n  colnames(ptab) <- rep(\"\", nm1+1)\r\n  \r\n  stem <- \"For the below discrete probability distribution, calculate the mean, variance, and standard deviation.\"\r\n  \r\n  list(stem=stem, \r\n       data=ptab, \r\n       hidden_data=list(tab=tab))\r\n}\r\n\r\n# Expected Value ----\r\nc5p_expect <- function(){\r\n  num_tick <- sample(100:1000, 1)\r\n  cost <- sample(1:10, 1)\r\n  prize <- sample(100:1000, 1)\r\n  \r\n  stem <- paste0(\"Consider a lottery game where \", num_tick, \" tickets are sold at $\", cost, \" each, and the winner gets a cash prize of $\", prize,\". How much money would you expect to gain if you purchased a ticket?\")\r\n  \r\n  list(stem=stem,\r\n       data=\"\",\r\n       hidden_data=list(num_tick=num_tick,\r\n                        cost=cost,\r\n                        prize=prize))\r\n}\r\n\r\n# Single Event Binomial ----\r\nc5p_sebin <- function(){\r\n  context_options <- c(\"a candy bar for breakfast\",\r\n                \"a car older than 10 years old\",\r\n                \"an Apple product\",\r\n                \"a deep, abiding (and sometime secretive) belief that Thor is the best super hero ever\")\r\n  context_probs <- c(rep(0.99/(length(context_options)-1), length(context_options)-1), 0.01) #making the easter egg...\r\n  context <- sample(context_options, prob=context_probs, 1)\r\n  \r\n  prob <- 0\r\n  k <- 1\r\n  while(prob < 0.01){ #make sure that we get reasonable numbers before moving on...\r\n    pn <- sample(5:10, 1) #the n for the probability\r\n    px <- sample(1:(pn-1),1)\r\n    \r\n    n <- sample(5:15, 1)\r\n    x <- sample(4:n, 1)\r\n    \r\n    prob <- dbinom(x,n,prob=px/pn)\r\n    k <- k+1\r\n    if(k>100) #if you do this more than 100 times... shouldn't be an issue: did this a bunch without hitting this...\r\n      stop(\"data generation error in c5p_sebin\")\r\n  }\r\n\r\n  stem <- paste0(\"In a recent study, it was determined that \", px, \" out of \", pn,\" Americans had \", context,\". If \", n, \" people are selected at random, find the probability that exactly \", x, \" will have \", context, \".\")\r\n  \r\n  list(stem=stem,\r\n       data=\"\",\r\n       hidden_data=list(p=px/pn,\r\n                        n=n,\r\n                        x=x))\r\n}\r\n\r\n# Binomial (mean, var, sd) ----\r\nc5p_binomial <- function(){\r\n  sides <- sample(4:10, 1) # for calculating the probability\r\n  soi <- sample(1:sides, 1)\r\n  n <- sample(5:1000, 1)\r\n  \r\n  stem <- paste0(\"Consider a case where a \", sides,\" sided die is rolled \", n, \" times. Find the mean, variance, and standard deviation of the number of \", soi,\"s rolled.\")\r\n  \r\n  list(stem=stem,\r\n       data=\"\",\r\n       hidden_data=list(p=1/sides,\r\n                        n=n))\r\n}\r\n\r\n# Complete Problem Function ----\r\nc5p <- function(prob_type=\"random\"){\r\n  prob_names <- c(\"discrete\", \"expect\", \"sebin\", \"binomial\")\r\n  ds <- sample(1:length(prob_names), size=1) #pick one type of problem, for if it is random\r\n  if(prob_type==\"random\"){\r\n    pn <- prob_names[ds] \r\n  } else {\r\n    if(!(prob_type %in% prob_names))\r\n      stop(paste0(\"There are not currently problems of that type. Problems must be one of the following: random, \", paste0(prob_names, collapse=\", \")))\r\n    pn <- prob_type\r\n  }\r\n  \r\n  if(pn == \"discrete\"){\r\n    out <- c5p_discrete()\r\n  } else if (pn == \"expect\"){\r\n    out <- c5p_expect()\r\n  } else if (pn == \"sebin\"){\r\n    out <- c5p_sebin()\r\n  } else if (pn == \"binomial\"){\r\n    out <- c5p_binomial()\r\n  } else {\r\n    stop(\"Problem type currently not supported in c5p.\")\r\n  }\r\n  out$hidden_data$prob_type <- pn\r\n  out\r\n}\r\n\r\n\r\n","type":"text"},{"name":"Problems/chapter 6 problems.R","content":"# Header ----\r\n# Description: 4 types of problems. z test to prob, z test to prob in context, prob to value in context, group mean z test.\r\n\r\n\r\n# Data ----\r\nsysbpdg <- function(n){sample(80:120, size=n, replace=TRUE)} #Systolic Blood Pressure\r\nagedg <- function(n){sample(18:38, size=n, replace=TRUE)} #olympic athletes\r\nweightdg <- function(n){sample(60:100, size=n, replace=TRUE)} #kilograms\r\nheightdg <- function(n){sample(157:193, size=n, replace=TRUE)} #centimeters\r\n\r\n\r\n\r\n\r\n# Problem Generation ----\r\nc6p_z2p <- function(direction=\"random\"){\r\n  z_value <- round(runif(1,-3,3),2)\r\n  rdirection <- sample(c(\"greater than\", \"less than\"), size=1) #do this here too (not needed, but just cause so that all randomization is done every time, and fixed values are set later if needed)\r\n  \r\n  if(direction==\"random\")\r\n    #getting direction (greater than, less than, ne to)\r\n    direction <- rdirection\r\n  if(!(direction %in% c(\"random\", \"greater than\", \"less than\"))) \r\n    stop('Direction must be \"random\", \"greater than\", or \"less than\".')\r\n  \r\n  stem <- paste0(\"Find the probability that z is \", direction, \" \",  fr(z_value, 2), \".\")\r\n  \r\n  list(stem=stem, data=\"\", hidden_data = list(direction=direction, z_value=z_value))\r\n}\r\n\r\nc6p_z2p_word <- function(direction=\"random\"){\r\n  z_value <- runif(1,-2.5,2.5)\r\n  n <- 15 # definitely needed here (can be constant)\r\n  ds <- sample(1:4, size=1) # 4 sets of problems: pick one.\r\n  dat <- list(sysbpdg(n), agedg(n), weightdg(n), heightdg(n))[[ds]] #do these two first so that we can play around with the direction and alpha without changing the data or the null hypothesis (ie we can look at a problem, then change the direction and alpha as desired while keeping that dataset).\r\n  rdirection <- sample(c(\"greater than\", \"less than\"), size=1) #do this here too (not needed, but just cause so that all randomization is done every time, and fixed values are set later if needed)\r\n  \r\n  if(direction==\"random\")\r\n    #getting direction (greater than, less than, ne to)\r\n    direction <- rdirection\r\n  if(!(direction %in% c(\"random\", \"greater than\", \"less than\"))) \r\n    stop('Direction must be \"random\", \"greater than\" or \"less than\".')\r\n  \r\n  voi <- c(\"systolic blood pressure\", \"age\", \"weight in kilograms\", \"height in centimeters\")[ds]\r\n  md <- round(mean(dat), 2) #mean of the data\r\n  sdd <- round(sd(dat), 2) #sd of the data\r\n  comp_val <- round(z_value*sdd + md) #comparison value (no decimals)\r\n  \r\n  \r\n  stem <- paste0(\"Consider \", voi, \". Assume that the American population has an average of \", md, \" with a standard deviation of \", sdd, \". Find the percentage of Americans who have a value \", direction, \" \", comp_val, \".\")\r\n  \r\n  \r\n  list(stem=stem, data=\"\", hidden_data = list(direction=direction, md=md, sdd=sdd, comp_val=comp_val))\r\n}\r\n\r\nc6p_z2p_samp <- function(n=NULL, direction=\"random\"){\r\n  if(is.null(n))\r\n    n <- sample(9:15, size=1) # dont think this is neeeded: shiny will give default values anyways...\r\n  z_value <- runif(1,-2.5,2.5)\r\n  ds <- sample(1:4, size=1) # 4 sets of problems: pick one.\r\n  dat <- list(sysbpdg(n), agedg(n), weightdg(n), heightdg(n))[[ds]] #do these two first so that we can play around with the direction and alpha without changing the data or the null hypothesis (ie we can look at a problem, then change the direction and alpha as desired while keeping that dataset).\r\n  rdirection <- sample(c(\"greater than\", \"less than\"), size=1) #do this here too (not needed, but just cause so that all randomization is done every time, and fixed values are set later if needed)\r\n  \r\n  if(direction==\"random\")\r\n    #getting direction (greater than, less than, ne to)\r\n    direction <- rdirection\r\n  if(!(direction %in% c(\"random\", \"greater than\", \"less than\"))) \r\n    stop('Direction must be \"random\", \"greater than\" or \"less than\".')\r\n  \r\n  voi <- c(\"systolic blood pressure\", \"age\", \"weight in kilograms\", \"height in centimeters\")[ds]\r\n  md <- round(mean(dat), 2) #mean of the data\r\n  sdd <- round(sd(dat), 2) #sd of the data\r\n  comp_val <- round(z_value*(sdd/sqrt(n)) + md) #comparison value (no decimals)\r\n  \r\n  \r\n  stem <- paste0(\"Consider \", voi, \". Assume that the American population has an average of \", md, \" with a standard deviation of \", sdd, \". If \", n, \" Americans are selected at random, find the probability that their mean \", voi, \" is \", direction, \" \", comp_val, \".\")\r\n  \r\n  \r\n  list(stem=stem, data=\"\", hidden_data = list(direction=direction, n=n, md=md, sdd=sdd, comp_val=comp_val))\r\n}\r\n\r\nc6p_p2v <- function(direction=\"random\"){\r\n  p <- round(runif(1, min=0.01, max=.30), 2)\r\n  n <- 15 # definitely needed here (can be constant)\r\n  ds <- sample(1:4, size=1) # 4 sets of problems: pick one.\r\n  dat <- list(sysbpdg(n), agedg(n), weightdg(n), heightdg(n))[[ds]] #do these two first so that we can play around with the direction and alpha without changing the data or the null hypothesis (ie we can look at a problem, then change the direction and alpha as desired while keeping that dataset).\r\n  rdirection <- sample(c(\"greater than\", \"less than\"), size=1) #do this here too (not needed, but just cause so that all randomization is done every time, and fixed values are set later if needed)\r\n  \r\n  if(direction==\"random\")\r\n    #getting direction (greater than, less than, ne to)\r\n    direction <- rdirection\r\n  if(!(direction %in% c(\"random\", \"greater than\", \"less than\"))) \r\n    stop('Direction must be \"random\", \"greater than\" or \"less than\".')\r\n  \r\n  if(direction==\"greater than\"){\r\n    pdir <- \"top\"\r\n  } else {\r\n    pdir <- \"bottom\"\r\n  }\r\n  \r\n  voi <- c(\"systolic blood pressure\", \"age\", \"weight in kilograms\", \"height in centimeters\")[ds]\r\n  md <- round(mean(dat), 2) #mean of the data\r\n  sdd <- round(sd(dat), 2) #sd of the data\r\n  \r\n  \r\n  stem <- paste0(\"Consider \", voi, \". Assume that the American population has an average of \", md, \" with a standard deviation of \", sdd, \". What value would you have to have to be in the \", pdir, \" \", p*100, \"%?\")\r\n  \r\n  \r\n  list(stem=stem, data=\"\", hidden_data = list(direction=direction, pdir=pdir, md=md, sdd=sdd, p=p))\r\n}\r\n\r\nc6p <- function(prob_type=\"random\", n=NULL, direction=\"random\"){\r\n  ds <- sample(1:4, size=1) # 4 types of problems: pick one.\r\n  prob_names <- c(\"z2p\", \"z2p_word\", \"z2p_samp\", \"p2v\")\r\n  if(prob_type==\"random\"){\r\n    pn <- prob_names[ds]\r\n  } else {\r\n    if(!(prob_type %in% prob_names))\r\n      stop(paste0(\"Problems must be one of the following: random, \", paste0(prob_names, collapse=\", \")))\r\n    pn <- prob_type\r\n  }\r\n  \r\n  if(pn == \"z2p\"){\r\n    out <- c6p_z2p(direction=direction)\r\n  } else if (pn == \"z2p_word\"){\r\n    out <- c6p_z2p_word(direction=direction)\r\n  } else if (pn == \"z2p_samp\"){\r\n    out <- c6p_z2p_samp(n=n, direction=direction)\r\n  } else if (pn == \"p2v\"){\r\n    out <- c6p_p2v(direction=direction)\r\n  }\r\n  out$hidden_data$prob_type <- pn\r\n  out\r\n}\r\n\r\n\r\n","type":"text"},{"name":"Problems/chapter 7 problems.R","content":"# Header ----\r\n# Notes: \r\n# Improvement ideas: eventually, consider generating data using a variety of different stems for different problems?\r\n# Continuous ----\r\nsysbpdg <- function(n){sample(80:120, size=n, replace=TRUE)} #Systolic Blood Pressure\r\nagedg <- function(n){sample(18:38, size=n, replace=TRUE)} #olympic athletes\r\nweightdg <- function(n){sample(60:100, size=n, replace=TRUE)} #kilograms\r\nheightdg <- function(n){sample(157:193, size=n, replace=TRUE)} #centimeters\r\n\r\nc7p_t <- function(n=NULL, alpha=\"random\"){\r\n  if(is.null(n))\r\n    n <- sample(9:15, size=1) # dont think this is neeeded: shiny will give default values anyways...\r\n  ds <- sample(1:4, size=1) # 4 sets of problems: pick one.\r\n  dat <- list(sysbpdg(n), agedg(n), weightdg(n), heightdg(n))[[ds]] #do these two first so that we can play around with the direction and alpha without changing the data or the null hypothesis (ie we can look at a problem, then change the direction and alpha as desired while keeping that dataset).\r\n  ralpha <- sample(c(0.01, 0.05, 0.10), size=1) #set this just in case (change later if we are using a fixed one). Setting here allows changes without out affecting randomization at all.\r\n  \r\n  if(alpha==\"random\"){\r\n    alpha <- ralpha\r\n  } else if(alpha!=\"random\"){ #if alpha isn't random, check that it is right\r\n    alpha <- as.numeric(alpha)\r\n    if(alpha>=1 | alpha<=0) #only need to check if the user sets alpha themselves.\r\n      stop(\"alpha must be a number between 0 and 1 (usually 0.05).\")\r\n  }\r\n  \r\n  stem_start <- c(\"Consider the data below on systolic blood pressure. Construct a\",\r\n                  \"Consider the data below on age. Construct a\",\r\n                  \"Consider the data below on weight in kilograms. Construct a\",\r\n                  \"Consider the data below on height in centimeters. Construct a\")[ds]\r\n  stem_end <- paste0((1-alpha)*100, \"% confidence interval for the mean.\")\r\n  stem <- paste(stem_start, stem_end)\r\n  \r\n  list(stem=stem, data=dat, hidden_data = list(data=dat, alpha=alpha))\r\n}\r\n\r\nc7p_z <- function(n=NULL, alpha=\"random\"){\r\n  if(is.null(n))\r\n    n <- sample(9:15, size=1) # dont think this is neeeded: shiny will give default values anyways...\r\n  ds <- sample(1:4, size=1) # 4 sets of problems: pick one.\r\n  dat <- list(sysbpdg(n), agedg(n), weightdg(n), heightdg(n))[[ds]] #do these two first so that we can play around with the direction and alpha without changing the data or the null hypothesis (ie we can look at a problem, then change the direction and alpha as desired while keeping that dataset).\r\n  sdd <- round(sd(dat))\r\n  ralpha <- sample(c(0.01, 0.05, 0.10), size=1) #set this just in case (change later if we are using a fixed one). Setting here allows changes without out affecting randomization at all.\r\n  \r\n  if(alpha==\"random\"){\r\n    alpha <- ralpha\r\n  } else if(alpha!=\"random\"){ #if alpha isn't random, check that it is right\r\n    alpha <- as.numeric(alpha)\r\n    if(alpha>=1 | alpha<=0) #only need to check if the user sets alpha themselves.\r\n      stop(\"alpha must be a number between 0 and 1 (usually 0.05).\")\r\n  }\r\n  \r\n  stem_start <- c(\"Consider the data below on systolic blood pressure. Construct a\",\r\n                  \"Consider the data below on age. Construct a\",\r\n                  \"Consider the data below on weight in kilograms. Construct a\",\r\n                  \"Consider the data below on height in centimeters. Construct a\")[ds]\r\n  stem_end <- paste0((1-alpha)*100, \"% confidence interval for the mean, assuming the population standard deviation is \", sdd, \".\")\r\n  stem <- paste(stem_start, stem_end)\r\n  \r\n  list(stem=stem, data=dat, hidden_data = list(data=dat, alpha=alpha, sdd=sdd))\r\n}\r\n\r\nc7p_p <- function(n=NULL, alpha=\"random\"){\r\n  if(is.null(n))\r\n    n <- sample(9:15, size=1) # dont think this is neeeded: shiny will give default values anyways...\r\n  ds <- sample(1:4, size=1, prob = c(.33,.33,.01,.33)) # 4 sets of problems: pick one (reduced weight on the Dr. Floren being the best prof ever)\r\n  x <- round(runif(1, min=.3, max=.7)*n) # population proportion\r\n  ralpha <- sample(c(0.01, 0.05, 0.10), size=1) #set this just in case (change later if we are using a fixed one). Setting here allows changes without out affecting randomization at all.\r\n  \r\n  if(alpha==\"random\"){\r\n    alpha <- ralpha\r\n  } else if(alpha!=\"random\"){ #if alpha isn't random, check that it is right\r\n    alpha <- as.numeric(alpha)\r\n    if(alpha>=1 | alpha<=0) #only need to check if the user sets alpha themselves.\r\n      stop(\"alpha must be a number between 0 and 1 (usually 0.05).\")\r\n  }\r\n  \r\n  stem_start <- c(\"Americans were recently asked if they believed that ghosts are real. Construct a\",\r\n                  \"Americans were recently asked if they believed that marijuana should be legalized. Construct a\",\r\n                  \"Americans were recently asked if they believed that Dr. Floren is the best prof ever (hey, whats the point of making these problems if I can't do blatant self-promotion?!). Construct a\",\r\n                  \"Americans were recently asked if they believed that Thor is the best super hero ever. Construct a\")[ds]\r\n  stem_end <- paste0((1-alpha)*100, \"% confidence interval for the proportion who said yes, assuming that \", x, \" said yes.\")\r\n  stem <- paste(n, stem_start, stem_end)\r\n  \r\n  list(stem=stem, data=\"\", hidden_data = list(alpha=alpha, n=n, x=x))\r\n}\r\n\r\nc7p <- function(prob_type=\"random\", n=NULL, alpha=\"random\"){\r\n  ds <- sample(1:3, size=1) # 3 types of problems: pick one.\r\n  prob_names <- c(\"z\", \"t\", \"p\")\r\n  if(prob_type==\"random\"){\r\n    pn <- prob_names[ds]\r\n  } else {\r\n    if(!(prob_type %in% prob_names))\r\n      stop(paste0(\"Problems must be one of the following: random, \", paste0(prob_names, collapse=\", \")))\r\n    pn <- prob_type\r\n  }\r\n  \r\n  if(pn == \"z\"){\r\n    out <- c7p_z(n=n, alpha=alpha)\r\n  } else if(pn == \"t\"){\r\n    out <- c7p_t(n=n, alpha=alpha)\r\n  } else if(pn == \"p\"){\r\n    out <- c7p_p(n=n, alpha=alpha)\r\n  }\r\n  out$hidden_data$prob_type <- pn\r\n  out\r\n}","type":"text"},{"name":"Problems/chapter 8 problems.R","content":"# Header ----\r\n# Notes: \r\n# Improvement ideas: eventually, consider generating data using a variety of different stems for different problems?\r\n# Data ----\r\nsysbpdg <- function(n){sample(80:120, size=n, replace=TRUE)} #Systolic Blood Pressure\r\nagedg <- function(n){sample(18:38, size=n, replace=TRUE)} #olympic athletes\r\nweightdg <- function(n){sample(60:100, size=n, replace=TRUE)} #kilograms\r\nheightdg <- function(n){sample(157:193, size=n, replace=TRUE)} #centimeters\r\nthorawesomenessdg <- function(n){sample(75:100, size=n, replace=TRUE)} #awesomeness\r\n\r\n\r\n# Z Test ----\r\nc8p_ztest <- function(n=NULL, direction=\"random\", alpha=\"random\"){\r\n  ts_range <- c(-4.5, 4.5) #range of test statistic \r\n  direction_list <- c(\"greater than\", \"less than\", \"not equal to\")\r\n  \r\n  if(is.null(n))\r\n    n <- sample(9:15, size=1)\r\n  \r\n  context_list <- c(\"systolic blood pressure\", \"age\", \"weight\", \"height\", \"how amazing people think Thor is\") #for stem\r\n  eep <- 0.01 #easter egg probability\r\n  ds <- sample(1:length(context_list), prob = c(rep((1-eep)/(length(context_list)-1), (length(context_list)-1)), eep), size=1) #pick 1 stem/context (used in selecting text and data)\r\n  dat <- list(sysbpdg(n), agedg(n), weightdg(n), heightdg(n), thorawesomenessdg(n))[[ds]] #do these two first so that we can play around with the direction and alpha without changing the data or the null hypothesis (ie we can look at a problem, then change the direction and alpha as desired while keeping that dataset).\r\n  h0 <- round(mean(dat) + runif(1,min(ts_range), max(ts_range))*sd(dat)/sqrt(length(dat)), 1) #this is both positive and negative\r\n  ralpha <- sample(c(0.01, 0.05, 0.10), size=1) #random alpha. set this just in case (change later if we are using a fixed one). Setting here allows changes without out affecting randomization at all.\r\n  rdirection <- sample(direction_list, size=1) #random direction. do this here too (not needed, but just cause so that all randomization is done every time, and fixed values are set later if needed)\r\n  sigma <- round(sd(dat))\r\n  \r\n  if(direction==\"random\")\r\n    #getting direction (greater than, less than, ne to)\r\n    direction <- rdirection\r\n  if(!(direction %in% direction_list)) \r\n    stop(paste0(\"Direction must be: \", paste0(direction_list, collapse=\", \"), \".\"))\r\n  \r\n  if(alpha==\"random\"){\r\n    alpha <- ralpha\r\n  } else if(alpha!=\"random\"){ #if alpha isn't random, check that it is right\r\n    alpha <- as.numeric(alpha)\r\n    if(alpha>=1 | alpha<=0) #only need to check if the user sets alpha themselves.\r\n      stop(\"alpha must be a number between 0 and 1 (usually 0.05).\")\r\n  }\r\n  \r\n  stem_start <- paste0(\"Consider the data below on \", context_list[ds], \". Test the hypothesis that the population mean is\")\r\n  stem_middle <- direction\r\n  stem_end <- paste0(h0, \" at the alpha=\", alpha, \" level.\")\r\n  stem_sd <- paste0(\"Assume the population standard deviation is \", sigma, \".\")\r\n  stem <- paste(stem_start, stem_middle, stem_end, stem_sd)\r\n  \r\n  list(stem=stem, data=dat, hidden_data = list(h0=h0, alpha=alpha, direction=direction,  data=dat, sigma=sigma))\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# T Test ----\r\nc8p_ttest <- function(n=NULL, direction=\"random\", alpha=\"random\"){\r\n  ts_range <- c(-4.5, 4.5) #range of test statistic \r\n  direction_list <- c(\"greater than\", \"less than\", \"not equal to\")\r\n  \r\n  if(is.null(n))\r\n    n <- sample(9:15, size=1)\r\n  \r\n  context_list <- c(\"systolic blood pressure\", \"age\", \"weight\", \"height\", \"how amazing people think Thor is\") #for stem\r\n  eep <- 0.01 #easter egg probability\r\n  ds <- sample(1:length(context_list), prob = c(rep((1-eep)/(length(context_list)-1), (length(context_list)-1)), eep), size=1) #pick 1 stem/context (used in selecting text and data)\r\n  dat <- list(sysbpdg(n), agedg(n), weightdg(n), heightdg(n), thorawesomenessdg(n))[[ds]] #do these two first so that we can play around with the direction and alpha without changing the data or the null hypothesis (ie we can look at a problem, then change the direction and alpha as desired while keeping that dataset).\r\n  h0 <- round(mean(dat) + runif(1,min(ts_range), max(ts_range))*sd(dat)/sqrt(length(dat)), 1) #this is both positive and negative\r\n  ralpha <- sample(c(0.01, 0.05, 0.10), size=1) #random alpha. set this just in case (change later if we are using a fixed one). Setting here allows changes without out affecting randomization at all.\r\n  rdirection <- sample(direction_list, size=1) #random direction. do this here too (not needed, but just cause so that all randomization is done every time, and fixed values are set later if needed)\r\n  \r\n  if(direction==\"random\")\r\n    #getting direction (greater than, less than, ne to)\r\n    direction <- rdirection\r\n  if(!(direction %in% direction_list)) \r\n    stop(paste0(\"Direction must be: \", paste0(direction_list, collapse=\", \"), \".\"))\r\n  \r\n  if(alpha==\"random\"){\r\n    alpha <- ralpha\r\n  } else if(alpha!=\"random\"){ #if alpha isn't random, check that it is right\r\n    alpha <- as.numeric(alpha)\r\n    if(alpha>=1 | alpha<=0) #only need to check if the user sets alpha themselves.\r\n      stop(\"alpha must be a number between 0 and 1 (usually 0.05).\")\r\n  }\r\n  \r\n  stem_start <- paste0(\"Consider the data below on \", context_list[ds], \". Test the hypothesis that the population mean is\")\r\n  stem_middle <- direction\r\n  stem_end <- paste0(h0, \" at the alpha=\", alpha, \" level.\")\r\n  stem <- paste(stem_start, stem_middle, stem_end)\r\n  \r\n  list(stem=stem, data=dat, hidden_data = list(h0=h0, alpha=alpha, direction=direction,  data=dat))\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# P Test ----\r\nc8p_ptest <- function(direction=\"random\", alpha=\"random\"){\r\n  ts_range <- c(-4.5, 4.5) #range of test statistic \r\n  direction_list <- c(\"greater than\", \"less than\", \"not equal to\")\r\n  \r\n  n <- sample(10:100, 1)\r\n  x <- sample(1:(n-1),1)\r\n  p <- x/n\r\n  \r\n  context_list <- c(\"a candy bar for breakfast\",\r\n                       \"a car older than 10 years old\",\r\n                       \"an Apple product\",\r\n                       \"a deep, abiding (and sometime secretive) belief that Thor is the best super hero ever\")\r\n  eep <- 0.01 #easter egg probability\r\n  ds <- sample(1:length(context_list), prob = c(rep((1-eep)/(length(context_list)-1), (length(context_list)-1)), eep), size=1) #pick 1 stem/context (used in selecting text and data)\r\n  p0 <- round(p + runif(1,min(ts_range), max(ts_range))*sqrt(p*(1-p)/n), 2) #this is both positive and negative; not perfectly accurate, but hopefully close enough (can tweak range if not)\r\n  if(p0>1) p0 <- 2-p0 #1-(p0-1), so how much higher is p0 then 1, then remove that from 1\r\n  if(p0<0) p0 <- abs(p0)\r\n  if(p0==0) p0 <- 0.10 #can't have 0\r\n  if(p0==1) p0 <- 0.90 #can't have 0\r\n  ralpha <- sample(c(0.01, 0.05, 0.10), size=1) #random alpha. set this just in case (change later if we are using a fixed one). Setting here allows changes without out affecting randomization at all.\r\n  rdirection <- sample(direction_list, size=1) #random direction. do this here too (not needed, but just cause so that all randomization is done every time, and fixed values are set later if needed)\r\n  \r\n  if(direction==\"random\")\r\n    #getting direction (greater than, less than, ne to)\r\n    direction <- rdirection\r\n  if(!(direction %in% direction_list)) \r\n    stop(paste0(\"Direction must be: \", paste0(direction_list, collapse=\", \"), \".\"))\r\n  \r\n  if(alpha==\"random\"){\r\n    alpha <- ralpha\r\n  } else if(alpha!=\"random\"){ #if alpha isn't random, check that it is right\r\n    alpha <- as.numeric(alpha)\r\n    if(alpha>=1 | alpha<=0) #only need to check if the user sets alpha themselves.\r\n      stop(\"alpha must be a number between 0 and 1 (usually 0.05).\")\r\n  }\r\n  \r\n  stem_start <- paste0(\"In a news article, it was reported that \", fr(p0*100,0),\"% Americans had \", context_list[ds],\". A researcher didn't think this sounded quite right, so they sampled \", n, \" people and found that \", x, \" people had \", context_list[ds],\". Test the hypothesis that the population proportion is\")\r\n  stem_middle <- direction\r\n  stem_end <- paste0(p0, \" at the alpha=\", alpha, \" level.\")\r\n  stem <- paste(stem_start, stem_middle, stem_end)\r\n  \r\n  list(stem=stem, data=\"\", hidden_data = list(p0=p0, alpha=alpha, direction=direction, n=n, x=x))\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Complete Problem Function ----\r\nc8p <- function(prob_type=\"random\", n=NULL, direction=\"random\", alpha=\"random\"){\r\n  prob_names <- c(\"ztest\", \"ttest\", \"ptest\")\r\n  ds <- sample(1:length(prob_names), size=1) #pick one type of problem, for if it is random\r\n  if(prob_type==\"random\"){\r\n    pn <- prob_names[ds] \r\n  } else {\r\n    if(!(prob_type %in% prob_names))\r\n      stop(paste0(\"There are not currently problems of that type. Problems must be one of the following: random, \", paste0(prob_names, collapse=\", \")))\r\n    pn <- prob_type\r\n  }\r\n  \r\n  if(pn == \"ztest\"){\r\n    out <- c8p_ztest(n=n, direction=direction, alpha=alpha)\r\n  } else if (pn == \"ttest\"){\r\n    out <- c8p_ttest(n=n, direction=direction, alpha=alpha)\r\n  } else if (pn == \"ptest\"){\r\n    out <- c8p_ptest(direction=direction, alpha=alpha)\r\n  } else {\r\n    stop(\"Problem type currently not supported in c8p.\")\r\n  }\r\n  \r\n  out$hidden_data$prob_type <- pn\r\n  out\r\n}\r\n\r\n\r\n\r\n\r\n\r\n","type":"text"},{"name":"README.md","content":"# Basic Statistics Course Homework Application\r\nThis project creates problems and solutions as an R Shiny app for students in a basic statistics course to use, for free!\r\n\r\nUsage is encouraged under most conditions. For usage request, please contact drmfloren@gmail.com!\r\n","type":"text"},{"name":"Solutions/chapter 2 solutions.R","content":"# Continuous tables and graphs ----\r\n# set.seed(12152018)\r\n# n <- 15\r\n# dat <- sample(80:120, size = n, replace = TRUE)\r\n# datasets: sysbp, diasbp, age, weight, height\r\n\r\n# making lower and upper bounds\r\nlnb <- function(dat, cw=NULL, numclass=NULL){\r\n  if(is.null(numclass))\r\n    numclass <- 7\r\n  minimum <- min(dat)\r\n  maximum <- max(dat)\r\n  if(is.null(cw)){\r\n    cw <- ceiling((maximum-minimum)/numclass)\r\n    if(cw==(maximum-minimum)/numclass)\r\n      cw <- cw+1\r\n  }\r\n  lcl <- minimum + 0:(numclass-1)*cw\r\n  ucl <- minimum + 1:numclass*cw - 1\r\n  lcb <- lcl-.5\r\n  ucb <- ucl+.5\r\n  breaks <- c(lcb, ucb[numclass])\r\n  list(numclass=numclass, minimum=minimum, maximum=maximum, cw=cw, lcl=lcl, ucl=ucl, lcb=lcb, ucb=ucb, breaks=breaks)\r\n}\r\n\r\nfd <- function(dat, cw=NULL, numclass=NULL){ #freq distribution\r\n  bounds <- lnb(dat, cw=cw, numclass=numclass)\r\n  numclass <- bounds$numclass\r\n  minimum <- bounds$minimum\r\n  maximum <- bounds$maximum\r\n  cw <- bounds$cw\r\n  lcl <- bounds$lcl\r\n  ucl <- bounds$ucl\r\n  lcb <- bounds$lcb\r\n  ucb <- bounds$ucb\r\n  breaks <- bounds$breaks\r\n  freqs <- hist(dat, breaks = breaks, plot=FALSE)$counts\r\n  rel_freqs <- paste0(freqs, \"/\", sum(freqs))\r\n  sim_rel_freqs <- as.character(MASS::fractions(freqs/sum(freqs))) #or this for simplified fractions\r\n  dec_rel_freqs <- round(freqs/sum(freqs),4)\r\n  percentages <- paste0(round(freqs/sum(freqs), 4)*100, \"%\")\r\n  cum_freqs <- cumsum(freqs)\r\n  midpoints <- (lcl+ucl)/2\r\n  fd <- data.frame(lcl, ucl, lcb, ucb, freqs, rel_freqs, sim_rel_freqs, dec_rel_freqs, percentages, cum_freqs, midpoints)\r\n  fd\r\n}\r\n\r\n# frequency distributions\r\nc2conts_all_text <- function(dat, cw=NULL, numclass=NULL){\r\n  bounds <- lnb(dat, cw=cw, numclass=numclass)\r\n  numclass <- bounds$numclass\r\n  minimum <- bounds$minimum\r\n  maximum <- bounds$maximum\r\n  cw <- bounds$cw\r\n  \r\n  fd <- fd(dat, cw=cw, numclass=numclass)\r\n  \r\n  #class width work\r\n  if(cw-1==(maximum-minimum)/numclass){ #if a whole number\r\n    cww <- paste0(\"cw = (max-min)/(# classes) = (\", maximum, \"-\", minimum,\")/\", numclass, \" = \", (maximum-minimum)/numclass, \". As this is a whole number, round up to cw = \", cw, \".\")\r\n  } else { #otherwise\r\n    cww <- paste0(\"cw = (max-min)/(# classes) = (\", maximum, \"-\", minimum,\")/\", numclass, \" = \", round((maximum-minimum)/numclass,4), \". Rounding up gives cw = \",cw)\r\n  }\r\n  \r\n  list(`Ordered Data`=sort(dat), `Number of Classes`=numclass, `Class Width`=cww, `All Frequency Distributions` = fd)\r\n}\r\n\r\n# frequency histograms\r\nfh <- function(dat, cw=NULL, numclass=NULL){\r\n  bounds <- lnb(dat, cw=cw, numclass=numclass)\r\n  breaks <- bounds$breaks\r\n  p <- hist(dat, breaks = breaks, plot=FALSE)\r\n  plot(p, xaxt=\"n\", xlab=\"***Description of Data***\", main=\"Frequency Histogram\", ylim=c(0, max(p$counts))); grid(nx=NA,ny=NULL)\r\n  axis(side=1, at=breaks, labels=breaks)\r\n}\r\n\r\n# relative frequency histogram\r\nrfh <- function(dat, cw=NULL, numclass=NULL){\r\n  bounds <- lnb(dat, cw=cw, numclass=numclass)\r\n  breaks <- bounds$breaks\r\n  p <- hist(dat, breaks = breaks, plot=FALSE)\r\n  p$counts <- p$counts/length(dat)\r\n  plot(p, xaxt=\"n\", xlab=\"***Description of Data***\", ylab = \"Relative Frequency\", main=\"Relative Frequency Histogram\", ylim=c(0, max(p$counts))); grid(nx=NA,ny=NULL)\r\n  axis(side=1, at=breaks, labels=breaks)\r\n}\r\n\r\n# frequency polygon\r\nfp <- function(dat, cw=NULL, numclass=NULL){\r\n  d <- fd(dat, cw=cw, numclass=numclass)\r\n  plot(d$midpoints, d$freqs, type = \"b\", xlab=\"***Description of Data***\",ylab=\"Frequency\", main=\"Frequency Polygon\", ylim = c(0, max(d$freqs)), xaxt=\"n\"); grid(nx=NA,ny=NULL)\r\n  axis(side=1, at=d$midpoints, labels=d$midpoints)\r\n}\r\n\r\n# relative frequency polygon\r\nrfp <- function(dat, cw=NULL, numclass=NULL){\r\n  d <- fd(dat, cw=cw, numclass=numclass)\r\n  plot(d$midpoints, d$dec_rel_freqs, type = \"b\", xlab=\"***Description of Data***\",ylab=\"Relative Frequency\", main=\"Relative Frequency Polygon\", ylim = c(0, max(d$dec_rel_freqs)), xaxt=\"n\"); grid(nx=NA,ny=NULL)\r\n  axis(side=1, at=d$midpoints, labels=d$midpoints)\r\n}\r\n\r\n# ogive: cumulative frequency polygon\r\nogive <- function(dat, cw=NULL, numclass=NULL){\r\n  d <- fd(dat, cw=cw, numclass=numclass)\r\n  plot(d$midpoints, d$cum_freqs, type = \"b\", xlab=\"***Description of Data***\",ylab=\"Frequency\", main=\"Ogive (Cumulative Frequency Polygon)\", ylim = c(0, max(d$cum_freqs)), xaxt=\"n\"); grid(nx=NA,ny=NULL)\r\n  axis(side=1, at=d$midpoints, labels=d$midpoints)\r\n}\r\n\r\n# stem and leaf plot (just putting the first digit on the left)\r\nslp <- function (X, scale = 1) { #base code from fmsb::gstem, edited to include a title\r\n  .stem.out <- capture.output(aplpack::stem.leaf(X, style = \"bare\", m = 1, depths = FALSE))\r\n  .stem.len <- length(.stem.out)\r\n  plot(c(1, 2), c(1, .stem.len), type = \"n\", axes = FALSE, xlab = \"\", ylab = \"\", main=\"Stem and Leaf Plot\")\r\n  text(rep(1, .stem.len), .stem.len:1, .stem.out, pos = 4)\r\n}\r\n\r\n\r\n\r\nc2conts_all_plots <- function(dat, cw=NULL, numclass=NULL){\r\n  par(mfrow=c(6,1), cex=1.2)\r\n  fh(dat, cw=cw, numclass=numclass)\r\n  rfh(dat, cw=cw, numclass=numclass)\r\n  fp(dat, cw=cw, numclass=numclass)\r\n  rfp(dat, cw=cw, numclass=numclass)\r\n  ogive(dat, cw=cw, numclass=numclass)\r\n  slp(dat)\r\n  par(mfrow=c(1,1))\r\n}\r\n\r\n\r\n\r\n\r\n# Categorical tables and graphs ----\r\n# set.seed(12152018)\r\n# dat <- sample(c(\"A\",\"B\",\"AB\",\"O\"), size = n, replace = TRUE)\r\n# datasets: blood type, fav color, race, position (sports team or business), eye color, hair color\r\n\r\nc2cats_all_text <- function(dat){\r\n  freqs <- table(dat)\r\n  rn <- names(freqs)\r\n  names(freqs) <- NULL\r\n  freqs <- as.numeric(freqs)\r\n  rel_freqs <- paste0(freqs, \"/\", sum(freqs))\r\n  sim_rel_freqs <- as.character(MASS::fractions(freqs/sum(freqs))) #or this for simplified fractions\r\n  dec_rel_freqs <- round(freqs/sum(freqs),4)\r\n  percentages <- paste0(round(freqs/sum(freqs), 4)*100, \"%\")\r\n  out <- data.frame(freqs, rel_freqs, sim_rel_freqs, dec_rel_freqs, percentages)\r\n  rownames(out) <- rn\r\n  list(`All Frequency Distributions`=out)\r\n}\r\n\r\n# table(dat)\r\n# table(dat)/length(dat)\r\n# \r\n# barplot(table(dat), main=\"Bar Chart\")\r\n# barplot(table(dat), density = 3, main=\"Bar Chart\"); grid(nx=NA,ny=NULL)\r\n# barplot(table(dat), col=\"white\")\r\n# barplot(sort(table(dat), decreasing = TRUE), col=rainbow(length(table(dat))), main=\"Pareto Chart\")\r\n# \r\n# pie(table(dat), labels = paste0(names(table(dat)), \": \",round(table(dat)/length(dat),4)*100, \"%\"), main=\"Pie Chart\")\r\n\r\nc2cats_all_plots <- function(dat){\r\n  par(mfrow=c(3,1), cex=1.2)\r\n  barplot(table(dat), col=\"white\", main=\"Bar Chart\"); grid(nx=NA,ny=NULL) #density=3 adds slashes\r\n  barplot(sort(table(dat), decreasing = TRUE), col=\"white\", main=\"Pareto Chart\"); grid(nx=NA,ny=NULL)\r\n  pie(table(dat), labels = paste0(names(table(dat)), \": \",round(table(dat)/length(dat),4)*100, \"%\"), main=\"Pie Chart\")\r\n  par(mfrow=c(1,1))\r\n}\r\n\r\n# if numeric, use c2cont, if not, use c2cat.\r\n# c2s <- function(dat, cw=NULL, numclass=NULL){\r\n#   if(is.numeric(dat)){\r\n#     c2cont(dat, cw, numclass)\r\n#   } else {\r\n#     c2cat(dat)\r\n#   }\r\n# }\r\n\r\n\r\n","type":"text"},{"name":"Solutions/chapter 3 solutions.R","content":"# set.seed(12152018)\r\n# n <- 15\r\n# dat <- sample(80:120, size = n, replace = TRUE)\r\n\r\n# central tendancy ----\r\nmd <- function(dat){ #mode function\r\n  x <- table(dat)\r\n  as.numeric(names(x)[which(x==max(x))])\r\n}\r\n\r\nmct <- function(dat){ #measures of central tendancy\r\n  list(mean=mean(dat), median=median(dat), mode=md(dat), midrange=sum(range(dat))/2)\r\n}\r\n\r\n# measures of variation ----\r\nmv <- function(dat){\r\n  pv <- round(sum((dat-mean(dat))^2/length(dat)),4)\r\n  psd <- round(sqrt(pv),4)\r\n  sv <- round(sum((dat-mean(dat))^2/(length(dat)-1)),4)\r\n  ssd <- round(sqrt(sv),4)\r\n  list(range=diff(range(dat)), pop_var=pv, pop_sd=psd, samp_var=sv, samp_sd=ssd)\r\n}\r\n\r\n# percentiles, quartiles, deciles ----\r\nlibrary(toOrdinal)\r\npw <- function(n, p){ #percentile work\r\n  if(n*p/100==ceiling(n*p/100)){ #if a whole number\r\n    paste0(\"c = (np)/100 = (\", n, \"*\", p,\")/100 = \", n*p/100, \". As this is a whole number, use the mean of the \", toOrdinal(n*p/100), \" and \", toOrdinal(n*p/100+1), \" numbers in the ordered dataset.\")\r\n  } else { #otherwise\r\n    paste0(\"c = (np)/100 = (\", n, \"*\", p,\")/100 = \", n*p/100, \". Rounding up gives the \", toOrdinal(ceiling(n*p/100)), \" position in the ordered dataseet.\")\r\n  }\r\n}\r\n\r\npqd <- function(dat){\r\n  n <- length(dat)\r\n  d1 <- paste0(\"d1: \", pw(n, 10), \" d1 = \", quantile(dat, probs=.1, type=2))\r\n  d2 <- paste0(\"d2: \", pw(n, 20), \" d2 = \", quantile(dat, probs=.2, type=2))\r\n  d3 <- paste0(\"d3: \", pw(n, 30), \" d3 = \", quantile(dat, probs=.3, type=2))\r\n  d4 <- paste0(\"d4: \", pw(n, 40), \" d4 = \", quantile(dat, probs=.4, type=2))\r\n  d5 <- paste0(\"d5: \", pw(n, 50), \" d5 = \", quantile(dat, probs=.5, type=2))\r\n  d6 <- paste0(\"d6: \", pw(n, 60), \" d6 = \", quantile(dat, probs=.6, type=2))\r\n  d7 <- paste0(\"d7: \", pw(n, 70), \" d7 = \", quantile(dat, probs=.7, type=2))\r\n  d8 <- paste0(\"d8: \", pw(n, 80), \" d8 = \", quantile(dat, probs=.8, type=2))\r\n  d9 <- paste0(\"d9: \", pw(n, 90), \" d9 = \", quantile(dat, probs=.9, type=2))\r\n  q1 <- paste0(\"q1: \", pw(n, 25), \" q1 = \", quantile(dat, probs=.25, type=2))\r\n  q2 <- paste0(\"q2: \", pw(n, 50), \" q2 = \", quantile(dat, probs=.5, type=2))\r\n  q3 <- paste0(\"q3: \", pw(n, 75), \" q3 = \", quantile(dat, probs=.75, type=2))\r\n  iqr <- quantile(dat, probs=.75, type=2)-quantile(dat, probs=.25, type=2); names(iqr) <- NULL\r\n  outs <- dat[which(dat < quantile(dat, probs=.25, type=2) - 1.5*iqr | dat > quantile(dat, probs=.75, type=2) + 1.5*iqr)]\r\n  out_range <- paste0(\"Anything less than Q1 - 1.5*IQR = \", quantile(dat, probs=.25, type=2) - 1.5*iqr, \" or greater than Q3 + 1.5*IQR = \", quantile(dat, probs=.75, type=2)+1.5*iqr, \" is an outlier. In this case, \", ifelse(length(outs)==0, \"there aren't any outliers.\", paste0(paste(outs, collapse=\", \"), \" are outliers.\")))\r\n  list(d1=d1,d2=d2,d3=d3,d4=d4,d5=d5,d6=d6,d7=d7,d8=d8,d9=d9, q1=q1, q2=q2, q3=q3, iqr=iqr, outliers=out_range)\r\n}\r\n\r\nc3s_text <- function(dat){\r\n  list(`Ordered Dataset`=sort(dat),\r\n       `Measures of Central Tendancy`=mct(dat), \r\n       `Measures of Variation`=mv(dat), \r\n       `Deciles and Quartiles`=pqd(dat))\r\n}\r\n\r\n\r\n\r\n# boxplot ----\r\nlibrary(qboxplot)\r\n#qboxplot(dat~dat, horizontal = TRUE, range=0) #without outliers\r\n#qboxplot(dat~dat, horizontal = TRUE) #with outliers\r\n\r\nc3s_plot <- function(dat, outliers=FALSE){\r\n  pqd <- list(q1=quantile(dat, probs=.25, type=2),\r\n              q2=quantile(dat, probs=.5, type=2),\r\n              q3=quantile(dat, probs=.75, type=2))\r\n  qdat <- data.frame(dat=dat)\r\n  if(outliers){\r\n    qboxplot(dat~dat, horizontal = TRUE, range=0, main=\"Boxplot with Outliers Plotted\", qtype=2, data=qdat)\r\n    #boxplot(dat, horizontal = TRUE)\r\n    # axis(side=1, at=min(dat), label = paste0(\"Min:\\n\",min(dat)), mgp=c(0,-4.5,0))\r\n    # axis(side=1, at=pqd$q1, label = paste0(\"Q1:\\n\", pqd$q1), mgp=c(0,-4.5,0))\r\n    # axis(side=1, at=pqd$q2, label = paste0(\"Q2:\\n\", pqd$q2), mgp=c(0,-4.5,0))\r\n    # axis(side=1, at=pqd$q3, label = paste0(\"Q3:\\n\", pqd$q3), mgp=c(0,-4.5,0))\r\n    # axis(side=1, at=max(dat), label = paste0(\"Max:\\n\", max(dat)), mgp=c(0,-4.5,0))\r\n  } else{\r\n    qboxplot(dat~dat, horizontal = TRUE, range=0, main=\"Boxplot with Outliers Not Plotted\", qtype=2, data=qdat)\r\n    #boxplot(dat, horizontal = TRUE)\r\n    axis(side=1, at=min(dat), label = paste0(\"Min:\\n\",min(dat)), mgp=c(0,-4.5,0), tick = FALSE)\r\n    axis(side=1, at=pqd$q1, label = paste0(\"Q1:\\n\", pqd$q1), mgp=c(0,-4.5,0), tick = FALSE)\r\n    axis(side=1, at=pqd$q2, label = paste0(\"Q2:\\n\", pqd$q2), mgp=c(0,-4.5,0), tick = FALSE)\r\n    axis(side=1, at=pqd$q3, label = paste0(\"Q3:\\n\", pqd$q3), mgp=c(0,-4.5,0), tick = FALSE)\r\n    axis(side=1, at=max(dat), label = paste0(\"Max:\\n\", max(dat)), mgp=c(0,-4.5,0), tick = FALSE)\r\n  }\r\n}\r\n","type":"text"},{"name":"Solutions/chapter 4 solutions.R","content":"# Header ----\r\n# Description: There are a TON of types of problems for this chapter, especially if I utilize multiple mediums (the goal). I'll start with a single medium, work all of the problems (and all of the solutions) then move on to the next one. Below is a list of problem types and mediums that should be covered.\r\n# Problem Types: Basic, Basic Compliment, Advanced Compliment, And with Replacement, And without Replacement, Or with Mutually Exclusive, Or without Mutually Exclusive, Conditional\r\n# Mediums (or context): Cards in a Deck, Balls in an Urn, Coins (when appropriate), Die (when appropriate), Empirical\r\n\r\n# Actually, lets make a matrix of when things are appropriate:\r\napprop <- structure(c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, \r\n                      TRUE, TRUE, TRUE, TRUE, TRUE, NA, TRUE, TRUE, TRUE, TRUE, TRUE, \r\n                      NA, NA, NA, NA, TRUE, TRUE, TRUE, TRUE, NA, TRUE, NA, NA, TRUE, \r\n                      TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE), .Dim = c(8L, 5L), .Dimnames = list(\r\n                        c(\"Basic\", \"Basic Complement\", \"Advanced Complement\", \"And w/ Rep\", \r\n                          \"And w/o Rep\", \"Or w/ ME\", \"Or w/o ME\", \"Conditional\"), c(\"Cards\", \r\n                                                                                    \"Balls\", \"Coins\", \"Die\", \"Empirical\")))\r\n\r\n# Cards ----\r\n## Basic Probability ----\r\nc4s_cards_basic <- function(type, id){\r\n  list(`Equation`=paste0(\"(#Success)/(#Total)\"),\r\n       `Fraction`= paste0(sum(deck_of_cards[[type]]==id),\"/52\"),\r\n       `Reduced Fraction`= paste0(MASS::fractions(sum(deck_of_cards[[type]]==id)/52)),\r\n       `Probability`= fr(sum(deck_of_cards[[type]]==id)/52, 4))\r\n}\r\n\r\n## Basic Complement ----\r\nc4s_cards_bascomp <- function(type, id){\r\n  list(`Equation`=paste0(\"1-P(x)\"),\r\n       `Fraction`= paste0(52-sum(deck_of_cards[[type]]==id),\"/52\"),\r\n       `Reduced Fraction`= paste0(MASS::fractions((52-sum(deck_of_cards[[type]]==id))/52)),\r\n       `Probability`= fr((52-sum(deck_of_cards[[type]]==id))/52, 4))\r\n}\r\n\r\n## Advanced Complement ----\r\nc4s_cards_advcomp <- function(type, id, n){\r\n  num <- seq(from=(52-sum(deck_of_cards[[type]]==id)), by=-1, length=n) #numerator and denominator, as vector\r\n  den <- seq(from=52, by=-1, length=n)\r\n  \r\n  id_stem <- id\r\n  if(type==\"suit\")\r\n    id_stem <- substr(id, start=1, stop=nchar(id)-1)\r\n  \r\n  list(`Equation`=paste0(\"1-P(no \", id_stem,\"s)\"),\r\n       `Probability of Complement`= paste0(paste0(\"P(no \", id_stem,\"s)\"), \" = \", paste0(\"(\", paste0(paste0(num, \"/\", den), collapse=\")*(\"), \")\"), \" = \", prod(num), \"/\", prod(den)),\r\n       `Fraction`= paste0(\"1-(\",prod(num), \"/\", prod(den), \") = \", prod(den)-prod(num), \"/\", prod(den)),\r\n       `Reduced Fraction`= paste0(MASS::fractions(1-prod(num)/prod(den), max.denominator=1e7)),\r\n       `Probability`= fr(1-prod(num)/prod(den), 4))\r\n}\r\n\r\n## And (with replacement) ----\r\nc4s_cards_and_wr <- function(type, id, n){\r\n  num <- numeric(length=n)\r\n  for(i in 1:n)\r\n    num[i] <- sum(deck_of_cards[[type]]==id[i])\r\n  den <- rep(52, n)\r\n  \r\n  id_stem <- id\r\n  if(type==\"suit\")\r\n    id_stem <- substr(id, start=1, stop=nchar(id)-1)\r\n  \r\n  list(`Equation`=paste0(\"P(\",paste0(id_stem, collapse=\",\"),\")\"),\r\n       `Work`= paste0(\"(\", paste0(paste0(num, \"/\", den), collapse=\")*(\"), \")\"),\r\n       `Fraction`= paste0(prod(num), \"/\", prod(den)),\r\n       `Reduced Fraction`= paste0(MASS::fractions(prod(num)/prod(den), max.denominator=1e7)),\r\n       `Probability`= fr(prod(num)/prod(den), 4))\r\n}\r\n\r\n## And (without replacement) ----\r\nc4s_cards_and_wor <- function(type, id, n){\r\n  num <- numeric(length=n)\r\n  for(i in 1:n)\r\n    num[i] <- sum(deck_of_cards[[type]]==id[i])\r\n  num <- num - (run_dup_tally(id)-1) #dup tally base is 1, so -1 to make base 0 (i.e., don't remove anything unless its the duplicate)\r\n  den <- seq(from=52, by=-1, length=n)\r\n  \r\n  id_stem <- id\r\n  if(type==\"suit\")\r\n    id_stem <- substr(id, start=1, stop=nchar(id)-1)\r\n  \r\n  list(`Equation`=paste0(\"P(\",paste0(id_stem, collapse=\",\"),\")\"),\r\n       `Work`= paste0(\"(\", paste0(paste0(num, \"/\", den), collapse=\")*(\"), \")\"),\r\n       `Fraction`= paste0(prod(num), \"/\", prod(den)),\r\n       `Reduced Fraction`= paste0(MASS::fractions(prod(num)/prod(den), max.denominator=1e7)),\r\n       `Probability`= fr(prod(num)/prod(den), 4))\r\n}\r\n\r\n## Or (with ME) ----\r\nc4s_cards_or_wme <- function(type, id){\r\n  num <- numeric(length=2) #only ever 2 cards\r\n  for(i in 1:2)\r\n    num[i] <- sum(deck_of_cards[[type]]==id[i])\r\n  den <- rep(52,2)\r\n  \r\n  id_stem <- id\r\n  if(type==\"suit\")\r\n    id_stem <- substr(id, start=1, stop=nchar(id)-1)\r\n  \r\n  list(`Equation`=paste0(\"P(\",paste0(id_stem, collapse=\" or \"),\")\"),\r\n       `Work`= paste0(\"(\", paste0(paste0(num, \"/\", den), collapse=\")+(\"), \")\"),\r\n       `Fraction`= paste0(sum(num), \"/52\"),\r\n       `Reduced Fraction`= paste0(MASS::fractions(sum(num)/52)),\r\n       `Probability`= fr(sum(num)/52, 4))\r\n}\r\n\r\n## Or (without ME) ----\r\nc4s_cards_or_wome <- function(type, id){\r\n  num <- numeric(length=2) #only ever 2 cards\r\n  for(i in 1:2)\r\n    num[i] <- sum(deck_of_cards[[type[i]]]==id[i])\r\n  den <- rep(52,2)\r\n  \r\n  id_stem <- id\r\n  id_stem[2] <- substr(id[2], start=1, stop=nchar(id[2])-1)\r\n  \r\n  list(`Equation`=paste0(\"P(\",paste0(id_stem, collapse=\" or \"),\")\"),\r\n       `Work`= paste0(\"(\", paste0(paste0(num, \"/\", den), collapse=\")+(\"), \")-(1/52)\"),\r\n       `Fraction`= paste0(sum(num)-1, \"/52\"),\r\n       `Reduced Fraction`= paste0(MASS::fractions((sum(num)-1)/52)),\r\n       `Probability`= fr((sum(num)-1)/52, 4))\r\n}\r\n\r\n## Card Solution Function ----\r\nc4s_cards <- function(prob_obj){ #get the list of hidden data and, depending on the problem type, use whatever parts are expected...\r\n  card_prob_type <- prob_obj$hidden_data$card_prob_type\r\n  hdat <- prob_obj$hidden_data\r\n  \r\n  if(card_prob_type == \"basic_prob\"){\r\n    out <- c4s_cards_basic(type=hdat$type, id=hdat$id)\r\n  } else if (card_prob_type == \"basic_comp\"){\r\n    out <- c4s_cards_bascomp(type=hdat$type, id=hdat$id)\r\n  } else if (card_prob_type == \"adv_comp\"){\r\n    out <- c4s_cards_advcomp(type=hdat$type, id=hdat$id, n=hdat$n)\r\n  } else if (card_prob_type == \"and_wr\"){\r\n    out <- c4s_cards_and_wr(type=hdat$type, id=hdat$id, n=hdat$n)\r\n  } else if (card_prob_type == \"and_wor\"){\r\n    out <- c4s_cards_and_wor(type=hdat$type, id=hdat$id, n=hdat$n)\r\n  } else if (card_prob_type == \"or_wme\"){\r\n    out <- c4s_cards_or_wme(type=hdat$type, id=hdat$id)\r\n  } else if (card_prob_type == \"or_wome\"){\r\n    out <- c4s_cards_or_wome(type=hdat$type, id=hdat$id) #no choice here: needs both suit and value...\r\n  } else {\r\n    stop(\"Problem type is not currently supported by c4s_cards.\")\r\n  }\r\n  out\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Empirical ----\r\n# Start with conditional probability, then move on.\r\nc4s_empirical_cond <- function(tab, wr, wc, wg){\r\n  cn <- colnames(tab)\r\n  rn <- rownames(tab)\r\n  \r\n  if(wg==\"r\"){\r\n    equation <- paste0(\"P(\", cn[wc], \"|\", rn[wr],\")\")\r\n    work <- paste0(\"n(\", cn[wc], \" and \", rn[wr],\") / n(\", rn[wr], \") = \", tab[wr,wc], \"/\", sum(tab[wr,]))\r\n    answer <- tab[wr,wc]/sum(tab[wr,])\r\n  } else if (wg==\"c\") {\r\n    equation <- paste0(\"P(\", rn[wr], \"|\", cn[wc],\")\")\r\n    work <- paste0(\"n(\", rn[wr], \" and \", cn[wc],\") / n(\", cn[wc], \") = \", tab[wr,wc], \"/\", sum(tab[,wc]))\r\n    answer <- tab[wr,wc]/sum(tab[,wc])\r\n  } else {\r\n    stop(\"error in wg entry to c4s_empirical_cond\")\r\n  }\r\n  \r\n  list(`Equation`= equation,\r\n       `Work`= work,\r\n       `Answer`= fr(answer, dig = 4))\r\n}\r\n# foo <- c4p_empirical_cond(); foo; c4s_empirical_cond(foo$data, foo$hidden_data$wr, foo$hidden_data$wc, foo$hidden_data$wg)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Other ----\r\n# These problems will note have any particular context associated with them...\r\n## Arranging ----\r\nc4s_other_arrange <- function(n){\r\n  list(`Equation`=paste0(\"n!\"),\r\n       `Work`= paste0(n,\"!\"),\r\n       `Answer`= factorial(n))\r\n}\r\nfoo <- c4p_other_arrange(); foo; c4s_other_arrange(foo$hidden_data$n)\r\n\r\n## Sample Space (fundamental counting rule) ----\r\nc4s_other_fcr <- function(die_faces){\r\n  n <- length(die_faces)\r\n\r\n  list(`Equation`= paste0(\"n(S) = (\", paste0(paste0(\"k_\", 1:n), collapse=\")*(\"), \")\"),\r\n       `Work`= paste0(\"n(S) = (\", paste0(die_faces, collapse=\")*(\"), \")\"),\r\n       `Answer`= prod(die_faces))\r\n}\r\nfoo <- c4p_other_fcr(); foo; c4s_other_fcr(foo$hidden_data$die_faces)\r\n\r\n## Combination ----\r\nc4s_other_combn <- function(n, r){\r\n  list(`Equation`=paste0(\"nCr = (n!) / ((n-r)!*r!)\"),\r\n       `Work`= paste0(n, \"C\", r, \" = (\", n, \"!) / ((\", n,\"-\", r,\")!*\", r,\"!)\"),\r\n       `Answer`= choose(n, r))\r\n}\r\n\r\n## Permutation ----\r\nc4s_other_perm <- function(n, r){\r\n  list(`Equation`=paste0(\"nPr = (n!) / (n-r)!\"),\r\n       `Work`= paste0(n, \"P\", r, \" = (\", n, \"!) / (\", n,\"-\", r,\")!\"),\r\n       `Answer`= choose(n, r) * factorial(r))\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Complete Solution Function ----\r\nc4s <- function(prob_obj){ #get the list of hidden data and, depending on the problem type, use whatever parts are expected...\r\n  prob_type <- prob_obj$hidden_data$prob_type\r\n  hdat <- prob_obj$hidden_data\r\n  \r\n  if(prob_type == \"basic_prob\"){\r\n    out <- c4s_cards_basic(type=hdat$type, id=hdat$id)\r\n  } else if (prob_type == \"basic_comp\"){\r\n    out <- c4s_cards_bascomp(type=hdat$type, id=hdat$id)\r\n  } else if (prob_type == \"adv_comp\"){\r\n    out <- c4s_cards_advcomp(type=hdat$type, id=hdat$id, n=hdat$n)\r\n  } else if (prob_type == \"and_wr\"){\r\n    out <- c4s_cards_and_wr(type=hdat$type, id=hdat$id, n=hdat$n)\r\n  } else if (prob_type == \"and_wor\"){\r\n    out <- c4s_cards_and_wor(type=hdat$type, id=hdat$id, n=hdat$n)\r\n  } else if (prob_type == \"or_wme\"){\r\n    out <- c4s_cards_or_wme(type=hdat$type, id=hdat$id)\r\n  } else if (prob_type == \"or_wome\"){\r\n    out <- c4s_cards_or_wome(type=hdat$type, id=hdat$id) #no choice here: needs both suit and value...\r\n  } else if (prob_type == \"cond\"){\r\n    out <- c4s_empirical_cond(tab=prob_obj$data, wr=hdat$wr, wc=hdat$wc, wg=hdat$wg)\r\n  } else if (prob_type == \"arrange\"){\r\n    out <- c4s_other_arrange(n=hdat$n)\r\n  } else if (prob_type == \"fcr\"){\r\n    out <- c4s_other_fcr(die_faces = hdat$die_faces)\r\n  } else if (prob_type == \"combn\"){\r\n    out <- c4s_other_combn(n=hdat$n, r=hdat$r)\r\n  } else if (prob_type == \"perm\"){\r\n    out <- c4s_other_perm(n=hdat$n, r=hdat$r)\r\n  } else {\r\n    stop(\"Problem type currently not supported in c4s.\")\r\n  }\r\n  out\r\n}\r\n# foo <- c4p(); foo; c4s(foo)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# foo <- problem\r\n# foo\r\n# soln(problem$hidden_data$, )\r\n","type":"text"},{"name":"Solutions/chapter 5 solutions.R","content":"\r\n\r\n# Discrete ----\r\nc5s_discrete <- function(tab){\r\n  \r\n  \r\n  mean <- list(Equation = paste0(\"Sum of (X*P(x))\"),\r\n               Work = paste0(\"(\", paste0(paste0(tab$x, \"*\", fr(tab$px,2)), collapse=\") + (\"), \")\"),\r\n               Answer = round(sum(tab$x*tab$px), 4))\r\n  \r\n  variance <- list(Equation = paste0(\"Sum of ((X-mu)^2*P(x))\"),\r\n                   Work = paste0(\"((\", paste0(paste0(tab$x, \"-\", mean$Answer, \")^2*\", fr(tab$px,2)), collapse=\") + (\"), \")\"),\r\n                   Answer = round(sum((tab$x-mean$Answer)^2*tab$px), 4))\r\n  \r\n  standard_deviation <- list(Equation = paste0(\"Square root of Variance\"),\r\n                       Work = paste0(\"Square root of \", variance$Answer),\r\n                       Answer = round(sqrt(variance$Answer), 4))\r\n  \r\n  list(\r\n    Mean = mean,\r\n    Variance = variance,\r\n    `Standard Deviation` = standard_deviation\r\n  )\r\n}\r\n# foo <- c5p_discrete(); foo; c5s_discrete(foo$hidden_data$tab)\r\n\r\n# Expected Value ----\r\nc5s_expect <- function(num_tick, cost, prize){\r\n  #win then lose...\r\n  pw <- round(1/num_tick, 4) #probability of a win\r\n  pl <- 1-pw\r\n  gain <- c(prize-cost, -cost)\r\n  \r\n  tab <- data.frame(x=gain, px=c(pw,pl))\r\n  \r\n  ptab <- t(tab)\r\n  ptab[2,] <- c(paste0(\"1/\", num_tick), paste0(num_tick-1, \"/\", num_tick))\r\n  rownames(ptab) <- c(\"Gain (X)\", \"P(X)\")\r\n  colnames(ptab) <- c(\"Win\", \"Lose\")\r\n  \r\n  \r\n  list(Table=ptab,\r\n       Equation = paste0(\"Sum of (X*P(x))\"),\r\n       Work = paste0(\"(\", paste0(paste0(tab$x, \"*\", fr(tab$px,4)), collapse=\") + (\"), \")\"),\r\n       Answer = paste0(\"$\",round(sum(tab$x*tab$px), 4)))\r\n}\r\n# foo <- c5p_expect(); foo; c5s_expect(foo$hidden_data$num_tick, foo$hidden_data$cost, foo$hidden_data$prize)\r\n\r\n# Single Event Binomial ----\r\nc5s_sebin <- function(p, n, x){\r\n  p <- round(p,4)\r\n  list(Equation = paste0(\"P(X=x) = (n!)/((n-x)!*x!) * p^x * q^(n-x)\"),\r\n       Work = paste0(\"P(X=\", x, \") = (\", n, \"!)/((\", n,\"-\", x,\")!*\", x,\"!) * \", p, \"^\", x, \" * \", 1-p, \"^(\", n, \"-\", x, \")\"),\r\n       Answer = round(dbinom(x, n, p),4))\r\n}\r\n# foo <- c5p_sebin(); foo; c5s_sebin(foo$hidden_data$p, foo$hidden_data$n, foo$hidden_data$x)\r\n\r\n# Binomial (mean, var, sd) ----\r\nc5s_binomial <- function(p, n){\r\n  fullp <- p\r\n  p <- round(p,4)\r\n  \r\n  mean <- list(Equation = paste0(\"n*p\"),\r\n               Work = paste0(n, \"*\", p),\r\n               Answer = round(n*p, 4))\r\n  \r\n  variance <- list(Equation = paste0(\"n*p*q\"),\r\n                   Work = paste0(n, \"*\", p, \"*\", 1-p),\r\n                   Answer = round(n*p*(1-p), 4))\r\n  \r\n  standard_deviation <- list(Equation = paste0(\"Square root of Variance\"),\r\n                       Work = paste0(\"Square root of \", variance$Answer),\r\n                       Answer = round(sqrt(variance$Answer), 4))\r\n  \r\n  list(Probability = paste0(\"p = \", MASS::fractions(fullp), \" = \", p),\r\n       Mean = mean,\r\n       Variance = variance,\r\n       `Standard Deviation` = standard_deviation)\r\n}\r\n# foo <- c5p_binomial(); foo; c5s_binomial(foo$hidden_data$p, foo$hidden_data$n)\r\n\r\n# Complete Solution Function ----\r\nc5s <- function(prob_obj){ #get the list of hidden data and, depending on the problem type, use whatever parts are expected...\r\n  prob_type <- prob_obj$hidden_data$prob_type\r\n  hdat <- prob_obj$hidden_data\r\n  \r\n  if(prob_type == \"discrete\"){\r\n    out <- c5s_discrete(tab = hdat$tab)\r\n  } else if (prob_type == \"expect\"){\r\n    out <- c5s_expect(num_tick=hdat$num_tick, cost=hdat$cost, prize=hdat$prize)\r\n  } else if (prob_type == \"sebin\"){\r\n    out <- c5s_sebin(p=hdat$p, n=hdat$n, x=hdat$x)\r\n  } else if (prob_type == \"binomial\"){\r\n    out <- c5s_binomial(p=hdat$p, n=hdat$n)\r\n  } else {\r\n    stop(\"Problem type currently not supported in c5p.\")\r\n  }\r\n  out\r\n}\r\n# foo <- c5p(); foo; c5s(foo)\r\n\r\n\r\n","type":"text"},{"name":"Solutions/chapter 6 solutions.R","content":"# Header ----\r\n# Description: 4 types of problems. z test to prob, z test to prob in context, prob to value in context, group mean z test.\r\n\r\n# Solution Generation ----\r\nc6s_z2p <- function(direction, z_value){\r\n  lt <- !(direction==\"greater than\")\r\n  list(`Probability` = fr(pnorm(z_value, lower.tail = lt), 4))\r\n}\r\n\r\nc6s_z2p_word <- function(direction, md, sdd, comp_val){\r\n  # Step 1: calculate z\r\n  z_value <- (comp_val - md)/sdd\r\n  s1 <- z_value\r\n  \r\n  # Step 2: find the area\r\n  lt <- !(direction==\"greater than\")\r\n  s2 <- paste0(fr(pnorm(z_value, lower.tail = lt)*100, 2), \"%\")\r\n  \r\n  list(`Z` = s1, `Percentage` = s2)\r\n}\r\n\r\nc6s_z2p_samp <- function(direction, n, md, sdd, comp_val){\r\n  # Step 1: calculate z\r\n  z_value <- (comp_val - md)/(sdd/sqrt(n))\r\n  s1 <- z_value\r\n  \r\n  # Step 2: find the area\r\n  lt <- !(direction==\"greater than\")\r\n  s2 <- fr(pnorm(z_value, lower.tail = lt), 4)\r\n  \r\n  list(`Z` = s1, `Probability` = s2)\r\n}\r\n\r\nc6s_p2v <- function(direction, md, sdd, p){\r\n  # Step 1: calculate z\r\n  lt <- !(direction==\"greater than\")\r\n  z_value <- qnorm(p, lower.tail = lt)\r\n  s1 <- round(z_value,2)\r\n  \r\n  # Step 2: find the value\r\n  s2 <- round(sdd*round(z_value,2) + md, 4)\r\n  \r\n  list(`Z` = s1, `Value` = s2)\r\n}\r\n\r\nc6s_text <- function(prob_type, hdat){ #get the list of hidden data and, depending on the problem type, use whatever parts are expected...\r\n  prob_names <- c(\"z2p\", \"z2p_word\", \"z2p_samp\", \"p2v\")\r\n  if(!(prob_type %in% prob_names))\r\n    stop(paste0(\"Problems must be one of the following: \", paste0(prob_names, collapse=\", \")))\r\n  \r\n  if(prob_type == \"z2p\"){\r\n    out <- c6s_z2p(direction=hdat$direction, z_value=hdat$z_value)\r\n  } else if (prob_type == \"z2p_word\"){\r\n    out <- c6s_z2p_word(direction=hdat$direction, md=hdat$md, sdd=hdat$sdd, comp_val=hdat$comp_val)\r\n  } else if (prob_type == \"z2p_samp\"){\r\n    out <- c6s_z2p_samp(direction=hdat$direction, n=hdat$n, md=hdat$md, sdd=hdat$sdd, comp_val=hdat$comp_val)\r\n  } else if (prob_type == \"p2v\"){\r\n    out <- c6s_p2v(direction=hdat$direction, md=hdat$md, sdd=hdat$sdd, p=hdat$p)\r\n  }\r\n  out\r\n}\r\n\r\n\r\n\r\n# Plot Generation ----\r\n# Generic plotting function for direction and Z\r\nzplot <- function(direction, z, tail_exp=1.1, bound=c(-3,3)){\r\n  lt <- !(direction==\"greater than\")\r\n  gt <- \"Z-Distribution\"\r\n    \r\n  lower_bound <- bound[1]*tail_exp\r\n  upper_bound <- bound[2]*tail_exp\r\n  x <- seq(lower_bound, upper_bound, by=.01)\r\n  y <- dnorm(x)\r\n  \r\n  #base plot\r\n  plot(x, y, main=gt, type=\"l\", xlab=\"t\", ylab=\"Density\")\r\n  \r\n  #shading area\r\n  if(direction==\"greater than\"){\r\n    lower_shade <- z\r\n    upper_shade <- upper_bound\r\n    axis(side=1, at=lower_shade, labels=paste0(\"Z=\", fr(lower_shade,2)), col.axis=\"blue\", mgp=c(0,2,0), col=\"blue\")\r\n  } else if (direction==\"less than\"){\r\n    lower_shade <- lower_bound\r\n    upper_shade <- z\r\n    axis(side=1, at=upper_shade, labels=paste0(\"Z=\", fr(upper_shade,2)), col.axis=\"blue\", mgp=c(0,2,0), col=\"blue\")\r\n  }\r\n  shade_x <- c(lower_shade, seq(lower_shade, upper_shade, by=.01), upper_shade)\r\n  shade_y <- c(0,dnorm(seq(lower_shade, upper_shade, by=.01)),0)\r\n  polygon(shade_x, shade_y, col=\"skyblue\")\r\n}\r\n\r\n\r\nc6s_plot <- function(prob_type, hdat){ #get the list of hidden data and, depending on the problem type, use whatever parts are expected...\r\n  prob_names <- c(\"z2p\", \"z2p_word\", \"z2p_samp\", \"p2v\")\r\n  if(!(prob_type %in% prob_names))\r\n    stop(paste0(\"Problems must be one of the following: \", paste0(prob_names, collapse=\", \")))\r\n  \r\n  if(prob_type == \"z2p\"){\r\n    zplot(direction=hdat$direction, z=hdat$z_value)\r\n    \r\n  } else if (prob_type == \"z2p_word\"){\r\n    z_value <- c6s_z2p_word(direction=hdat$direction, md=hdat$md, sdd=hdat$sdd, comp_val=hdat$comp_val)$Z\r\n    zplot(direction=hdat$direction, z=z_value)\r\n    \r\n  } else if (prob_type == \"z2p_samp\"){\r\n    z_value <- c6s_z2p_samp(direction=hdat$direction, n=hdat$n, md=hdat$md, sdd=hdat$sdd, comp_val=hdat$comp_val)$Z\r\n    zplot(direction=hdat$direction, z=z_value)\r\n    \r\n  } else if (prob_type == \"p2v\"){\r\n    z_value <- c6s_p2v(direction=hdat$direction, md=hdat$md, sdd=hdat$sdd, p=hdat$p)$Z\r\n    zplot(direction=hdat$direction, z=z_value)\r\n  }\r\n}\r\n","type":"text"},{"name":"Solutions/chapter 7 solutions.R","content":"\r\nfr <- function(x, dig=4){\r\n  format(round(x, digits = dig), nsmall=dig)\r\n}\r\n\r\n# Text Solutions ----\r\nc7s_t <- function(data, alpha, dig=3){\r\n  n <- length(data)\r\n  df <- n-1\r\n  mu <- mean(data)\r\n  t <- qt(c(alpha/2, 1-alpha/2), df)\r\n  se <- sd(data)/sqrt(n) #note: this works for t, but need to change var/sd calculation for z...\r\n  \r\n  # Step 1: Pieces\r\n  s1 <- list(mu = fr(mu),\r\n             df = df,\r\n             t = fr(t),\r\n             sd = fr(sd(data)),\r\n             se = fr(se))\r\n  \r\n  # Step 2a: PM Confidence Interval\r\n  pm <- paste0(fr(mu), \" \\u00B1 \", fr(max(t)*se)) #\\u00B1 or \r\n  \r\n  # Step 2b: Evaluated Confidence Interval\r\n  ev <- paste0(\"(\", fr(mu + min(t)*se), \", \", fr(mu + max(t)*se), \")\")\r\n  \r\n  list(`Pieces`=s1, \r\n       `Confidence Interval (plus/minus)` = pm,\r\n       `Confidence Interval (evaluated)` = ev)\r\n}\r\n\r\nc7s_z <- function(data, alpha, sdd, dig=3){\r\n  n <- length(data)\r\n  mu <- mean(data)\r\n  z <- qnorm(c(alpha/2, 1-alpha/2))\r\n  se <- sdd/sqrt(n)\r\n  \r\n  # Step 1: Pieces\r\n  s1 <- list(mu = fr(mu),\r\n             z = fr(z),\r\n             se = fr(se))\r\n  \r\n  # Step 2a: PM Confidence Interval\r\n  pm <- paste0(fr(mu), \" \\u00B1 \", fr(max(z)*se)) #\\u00B1 or \r\n  \r\n  # Step 2b: Evaluated Confidence Interval\r\n  ev <- paste0(\"(\", fr(mu + min(z)*se), \", \", fr(mu + max(z)*se), \")\")\r\n  \r\n  list(`Pieces`=s1, \r\n       `Confidence Interval (plus/minus)` = pm,\r\n       `Confidence Interval (evaluated)` = ev)\r\n}\r\n\r\nc7s_p <- function(alpha, n, x, dig=3){\r\n  p <- round(x/n,4)\r\n  q <- 1-p\r\n  z <- qnorm(c(alpha/2, 1-alpha/2))\r\n  se <- sqrt(p*q/n)\r\n  \r\n  # Step 1: Pieces\r\n  s1 <- list(p = fr(p),\r\n             z = fr(z),\r\n             se = fr(se))\r\n  \r\n  # Step 2a: PM Confidence Interval\r\n  pm <- paste0(fr(p), \" \\u00B1 \", fr(max(z)*se)) #\\u00B1 or \r\n  \r\n  # Step 2b: Evaluated Confidence Interval\r\n  ev <- paste0(\"(\", fr(p + min(z)*se), \", \", fr(p + max(z)*se), \")\")\r\n  \r\n  list(`Pieces`=s1, \r\n       `Confidence Interval (plus/minus)` = pm,\r\n       `Confidence Interval (evaluated)` = ev)\r\n}\r\n\r\nc7s_text <- function(prob_type, hdat){\r\n  prob_names <- c(\"z\", \"t\", \"p\")\r\n\r\n  if(!(prob_type %in% prob_names))\r\n    stop(paste0(\"Problems must be one of the following: random, \", paste0(prob_names, collapse=\", \")))\r\n  pn <- prob_type\r\n  \r\n  if(pn == \"z\"){\r\n    out <- c7s_z(data = hdat$dat, alpha = hdat$alpha, sdd = hdat$sdd)\r\n  } else if(pn == \"t\"){\r\n    out <- c7s_t(data = hdat$dat, alpha = hdat$alpha)\r\n  } else if(pn == \"p\"){\r\n    out <- c7s_p(alpha = hdat$alpha, n = hdat$n, x = hdat$x)\r\n  }\r\n  out\r\n}\r\n\r\n# Plot Solutions ----\r\nc7s_tplot <- function(data, alpha, tail_exp=1.2){\r\n  df <- length(data)-1\r\n  \r\n  gt <- paste0(\"T-Distribution with df=\", df, \" and Alpha=\", alpha, \": Two-Tailed\")\r\n  lower_bound <- -4 #qt(alpha/2, df=df)*tail_exp # I think I prefer keeping these static... I think +-4 keeps them big enough so that the graphs won't go off of the bounds...\r\n  upper_bound <- 4 #qt(1-alpha/2, df=df)*tail_exp\r\n  x <- seq(lower_bound, upper_bound, by=.01)\r\n  y <- dt(x, df=df)\r\n  \r\n  #base plot\r\n  plot(x, y, main=gt, type=\"l\", xlab=\"t\", ylab=\"Density\", ylim=c(0,.4))\r\n  \r\n  #shading area\r\n  lower_shade_l <- lower_bound\r\n  upper_shade_l <- qt(alpha/2, df=df)\r\n  shade_x_l <- c(lower_shade_l, seq(lower_shade_l, upper_shade_l, by=.01), upper_shade_l)\r\n  shade_y_l <- c(0,dt(seq(lower_shade_l, upper_shade_l, by=.01), df=df),0)\r\n  \r\n  lower_shade_u <- qt(1-alpha/2, df=df)\r\n  upper_shade_u <- upper_bound\r\n  shade_x_u <- c(lower_shade_u, seq(lower_shade_u, upper_shade_u, by=.01), upper_shade_u)\r\n  shade_y_u <- c(0,dt(seq(lower_shade_u, upper_shade_u, by=.01), df=df),0)\r\n  \r\n  axis(side=1, at=upper_shade_l, labels=paste0(\"T=\", fr(upper_shade_l,2)), col.axis=\"blue\", mgp=c(0,2,0), col=\"blue\")\r\n  axis(side=1, at=lower_shade_u, labels=paste0(\"T=\", fr(lower_shade_u,2)), col.axis=\"blue\", mgp=c(0,2,0), col=\"blue\")\r\n  \r\n  polygon(shade_x_l, shade_y_l, col=\"skyblue\")\r\n  polygon(shade_x_u, shade_y_u, col=\"skyblue\")\r\n}\r\n\r\nc7s_zplot <- function(alpha, tail_exp=1.2){\r\n  gt <- paste0(\"Z-Distribution with Alpha=\", alpha,\": Two-Tailed\")\r\n  \r\n  lower_bound <- -3 #qnorm(alpha/2)*tail_exp\r\n  upper_bound <- 3 #qnorm(1-alpha/2)*tail_exp\r\n  x <- seq(lower_bound, upper_bound, by=.01)\r\n  y <- dnorm(x)\r\n  \r\n  #base plot\r\n  plot(x, y, main=gt, type=\"l\", xlab=\"t\", ylab=\"Density\")\r\n  \r\n  #shading area\r\n  lower_shade_l <- lower_bound\r\n  upper_shade_l <- qnorm(alpha/2)\r\n  shade_x_l <- c(lower_shade_l, seq(lower_shade_l, upper_shade_l, by=.01), upper_shade_l)\r\n  shade_y_l <- c(0,dnorm(seq(lower_shade_l, upper_shade_l, by=.01)),0)\r\n  \r\n  lower_shade_u <- qnorm(1-alpha/2)\r\n  upper_shade_u <- upper_bound\r\n  shade_x_u <- c(lower_shade_u, seq(lower_shade_u, upper_shade_u, by=.01), upper_shade_u)\r\n  shade_y_u <- c(0,dnorm(seq(lower_shade_u, upper_shade_u, by=.01)),0)\r\n  \r\n  axis(side=1, at=upper_shade_l, labels=paste0(\"Z=\", fr(upper_shade_l,2)), col.axis=\"blue\", mgp=c(0,2,0), col=\"blue\")\r\n  axis(side=1, at=lower_shade_u, labels=paste0(\"Z=\", fr(lower_shade_u,2)), col.axis=\"blue\", mgp=c(0,2,0), col=\"blue\")\r\n  \r\n  polygon(shade_x_l, shade_y_l, col=\"skyblue\")\r\n  polygon(shade_x_u, shade_y_u, col=\"skyblue\")\r\n}\r\n\r\nc7s_plot <- function(prob_type, hdat){\r\n  prob_names <- c(\"z\", \"t\", \"p\")\r\n  \r\n  if(!(prob_type %in% prob_names))\r\n    stop(paste0(\"Problems must be one of the following: random, \", paste0(prob_names, collapse=\", \")))\r\n  pn <- prob_type\r\n  \r\n  if(pn == \"z\"){\r\n    c7s_zplot(alpha = hdat$alpha)\r\n    \r\n  } else if(pn == \"t\"){\r\n    c7s_tplot(data=hdat$data, alpha = hdat$alpha)\r\n    \r\n  } else if(pn == \"p\"){\r\n    c7s_zplot(alpha = hdat$alpha)\r\n  }\r\n}\r\n","type":"text"},{"name":"Solutions/chapter 8 solutions.R","content":"\r\n\r\n# Z Test ----\r\n## Z Test Steps ----\r\nc8s_ztest_steps <- function(data, sigma=NULL, direction, alpha, nh=0, cv_dig=2, ts_dig=4){\r\n  # checking on df if it is a t-test\r\n  if(is.null(sigma))\r\n    stop(\"Need population standard deviation for the z-test.\")\r\n  \r\n  # Step 1: Stating the Hypothesis\r\n  if(direction==\"less than\"){\r\n    s1 <- paste0(\"H0: mu = \", nh, \"   vs   H1: mu < \", nh)\r\n  } else if(direction==\"greater than\"){\r\n    s1 <- paste0(\"H0: mu = \", nh, \"   vs   H1: mu > \", nh)\r\n  } else if(direction==\"not equal to\"){\r\n    s1 <- paste0(\"H0: mu = \", nh, \"   vs   H1: mu != \", nh)\r\n  }\r\n  \r\n  # Step 2: Finding the Critical Value\r\n  if(direction==\"less than\"){\r\n    cv <- round(qnorm(alpha), dig=cv_dig)\r\n  } else if(direction==\"greater than\"){\r\n    cv <- round(qnorm(1-alpha), dig=cv_dig)\r\n  } else if(direction==\"not equal to\"){\r\n    cv <- round(qnorm(c(alpha/2, 1-alpha/2)), dig=cv_dig)\r\n  }\r\n  \r\n  # Step 3: Computing the Test Statistic\r\n  n <- length(data)\r\n  ts <- round((mean(data) - nh)/sqrt(sigma^2/n), dig=ts_dig)\r\n  \r\n  # Step 4: Make the Decision\r\n  if(direction==\"less than\"){\r\n    if(ts<cv){\r\n      s4 <- paste0(\"Since \", ts, \" is less than \", cv, \", we reject the null hypothesis.\")\r\n    } else {\r\n      s4 <- paste0(\"Since \", ts, \" is not less than \", cv, \", we fail to reject the null hypothesis.\")\r\n    }\r\n    \r\n  } else if(direction==\"greater than\"){\r\n    if(ts>cv){\r\n      s4 <- paste0(\"Since \", ts, \" is greater than \", cv, \", we reject the null hypothesis.\")\r\n    } else {\r\n      s4 <- paste0(\"Since \", ts, \" is not greater than \", cv, \", we fail to reject the null hypothesis.\")\r\n    }\r\n    \r\n  } else if(direction==\"not equal to\"){\r\n    if(ts>max(cv)){\r\n      s4 <- paste0(\"Since \", ts, \" is greater than \", max(cv), \", we reject the null hypothesis.\")\r\n    } else if (ts<min(cv)){\r\n      s4 <- paste0(\"Since \", ts, \" is less than \", min(cv), \", we reject the null hypothesis.\")\r\n    } else {\r\n      s4 <- paste0(\"Since \", ts, \" is between \", max(cv), \" and \", min(cv), \", we fail to reject the null hypothesis.\")\r\n    }\r\n  }\r\n  \r\n  \r\n  list(`Step 1`=s1, \r\n       `Step 2`=paste0(\"Critical Value(s): \", paste0(cv, collapse=\", \")), \r\n       `Step 3`=paste0(\"Test Statistic: z = (x_bar-mu_0)/(sigma/sqrt(n)) = (\", round(mean(data),ts_dig), \"-\", nh,\")/(\", sigma, \"/sqrt(\", n,\")) = \", ts), \r\n       `Step 4`=s4, \r\n       `Step 5`=\"Translate Step 4 into a context dependent answer to the research question.\")\r\n}\r\n# foo <- c8p_ztest(); foo; z_test_steps(foo$hidden_data$data, foo$hidden_data$sigma, foo$hidden_data$direction, foo$hidden_data$alpha, foo$hidden_data$h0)\r\n\r\n## Z Test Plot ----\r\nc8s_ztest_plot <- function(data, sigma=NULL, direction, alpha, nh=0, cv_dig=2, ts_dig=4, tail_exp=1.1, type=\"z\"){\r\n  gt <- \"Z-Distribution for the Z-Test\\n(reject in shaded region)\"\r\n  \r\n  # Keep until ptest plot is made, but these shouldn't be together (as they don't require the same input)\r\n  # if(type==\"z\"){\r\n  #   gt <- \"Z-Distribution for the Z-Test\\n(reject in shaded region)\"\r\n  # } else if (type==\"p\"){\r\n  #   gt <- \"Z-Distribution for the Test of Proportions\\n(reject in shaded region)\"\r\n  # }\r\n  \r\n  # Computing the Test Statistic\r\n  n <- length(data)\r\n  ts <- round((mean(data) - nh)/sqrt(sigma^2/n), dig=ts_dig)\r\n  \r\n  if(ts < qnorm(alpha/2) | ts > qnorm(1-alpha/2)){\r\n    lower_bound <- -abs(ts)*tail_exp\r\n    upper_bound <- abs(ts)*tail_exp\r\n    x <- seq(lower_bound, upper_bound, by=.01)\r\n    y <- dnorm(x)\r\n  } else{\r\n    lower_bound <- qnorm(alpha/2)*tail_exp\r\n    upper_bound <- qnorm(1-alpha/2)*tail_exp\r\n    x <- seq(lower_bound, upper_bound, by=.01)\r\n    y <- dnorm(x)\r\n  }\r\n\r\n  #base plot\r\n  if(abs(ts)<0.3){ #if we get too close to the middle, need to extend the plot upwards so the label appears...\r\n    plot(x, y, main=gt, type=\"l\", xlab=\"z\", ylab=\"Density\", ylim=c(0,max(y)*1.1))\r\n  } else {\r\n    plot(x, y, main=gt, type=\"l\", xlab=\"z\", ylab=\"Density\")\r\n  }\r\n  \r\n  #shading area\r\n  if(direction!=\"not equal to\"){\r\n    if(direction==\"greater than\"){\r\n      lower_shade <- qnorm(1-alpha)\r\n      upper_shade <- upper_bound\r\n      axis(side=1, at=lower_shade, labels=paste0(\"CV=\", fr(lower_shade,2)), col.axis=\"blue\", mgp=c(0,2,0), col=\"blue\")\r\n    } else if (direction==\"less than\"){\r\n      lower_shade <- lower_bound\r\n      upper_shade <- qnorm(alpha)\r\n      axis(side=1, at=upper_shade, labels=paste0(\"CV=\", fr(upper_shade,2)), col.axis=\"blue\", mgp=c(0,2,0), col=\"blue\")\r\n    }\r\n    shade_x <- c(lower_shade, seq(lower_shade, upper_shade, by=.01), upper_shade)\r\n    shade_y <- c(0,dnorm(seq(lower_shade, upper_shade, by=.01)),0)\r\n    polygon(shade_x, shade_y, col=\"skyblue\")\r\n  } else if (direction==\"not equal to\"){\r\n    lower_shade_l <- lower_bound\r\n    upper_shade_l <- qnorm(alpha/2)\r\n    shade_x_l <- c(lower_shade_l, seq(lower_shade_l, upper_shade_l, by=.01), upper_shade_l)\r\n    shade_y_l <- c(0,dnorm(seq(lower_shade_l, upper_shade_l, by=.01)),0)\r\n    \r\n    lower_shade_u <- qnorm(1-alpha/2)\r\n    upper_shade_u <- upper_bound\r\n    shade_x_u <- c(lower_shade_u, seq(lower_shade_u, upper_shade_u, by=.01), upper_shade_u)\r\n    shade_y_u <- c(0,dnorm(seq(lower_shade_u, upper_shade_u, by=.01)),0)\r\n    \r\n    axis(side=1, at=upper_shade_l, labels=paste0(\"CV=\", fr(upper_shade_l,2)), col.axis=\"blue\", mgp=c(0,2,0), col=\"blue\")\r\n    axis(side=1, at=lower_shade_u, labels=paste0(\"CV=\", fr(lower_shade_u,2)), col.axis=\"blue\", mgp=c(0,2,0), col=\"blue\")\r\n    \r\n    polygon(shade_x_l, shade_y_l, col=\"skyblue\")\r\n    polygon(shade_x_u, shade_y_u, col=\"skyblue\")\r\n  }\r\n  \r\n  #plotting ts\r\n  ts_col <- \"red\"\r\n  segments(x0=ts, y=0, x1=ts, y1=dnorm(ts), col=ts_col)\r\n  text(x=ts, y=dnorm(ts), labels = paste0(\"TS = \", round(ts,2)), col=ts_col, offset = 1, pos=3)\r\n}\r\n# foo <- c8p_ztest(); foo; c8s_ztest_plot(foo$hidden_data$data, foo$hidden_data$sigma, foo$hidden_data$direction, foo$hidden_data$alpha, foo$hidden_data$h0)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# T Test ----\r\n## T Test Steps ----\r\nc8s_ttest_steps <- function(data, direction, alpha, nh=0, cv_dig=2, ts_dig=4){\r\n  n <- length(data)\r\n  df <- n-1\r\n  \r\n  # Step 1: Stating the Hypothesis\r\n  if(direction==\"less than\"){\r\n    s1 <- paste0(\"H0: mu = \", nh, \"   vs   H1: mu < \", nh)\r\n  } else if(direction==\"greater than\"){\r\n    s1 <- paste0(\"H0: mu = \", nh, \"   vs   H1: mu > \", nh)\r\n  } else if(direction==\"not equal to\"){\r\n    s1 <- paste0(\"H0: mu = \", nh, \"   vs   H1: mu != \", nh)\r\n  }\r\n  \r\n  # Step 2: Finding the Critical Value\r\n  if(direction==\"less than\"){\r\n    cv <- round(qt(alpha, df=df), dig=cv_dig)\r\n  } else if(direction==\"greater than\"){\r\n    cv <- round(qt(1-alpha, df=df), dig=cv_dig)\r\n  } else if(direction==\"not equal to\"){\r\n    cv <- round(qt(c(alpha/2, 1-alpha/2), df=df), dig=cv_dig)\r\n  }\r\n  \r\n  # Step 3: Computing the Test Statistic\r\n  ts <- round((mean(data) - nh)/sqrt(var(data)/n), dig=ts_dig)\r\n  \r\n  # Step 4: Make the Decision\r\n  if(direction==\"less than\"){\r\n    if(ts<cv){\r\n      s4 <- paste0(\"Since \", ts, \" is less than \", cv, \", we reject the null hypothesis.\")\r\n    } else {\r\n      s4 <- paste0(\"Since \", ts, \" is not less than \", cv, \", we fail to reject the null hypothesis.\")\r\n    }\r\n    \r\n  } else if(direction==\"greater than\"){\r\n    if(ts>cv){\r\n      s4 <- paste0(\"Since \", ts, \" is greater than \", cv, \", we reject the null hypothesis.\")\r\n    } else {\r\n      s4 <- paste0(\"Since \", ts, \" is not greater than \", cv, \", we fail to reject the null hypothesis.\")\r\n    }\r\n    \r\n  } else if(direction==\"not equal to\"){\r\n    if(ts>max(cv)){\r\n      s4 <- paste0(\"Since \", ts, \" is greater than \", max(cv), \", we reject the null hypothesis.\")\r\n    } else if (ts<min(cv)){\r\n      s4 <- paste0(\"Since \", ts, \" is less than \", min(cv), \", we reject the null hypothesis.\")\r\n    } else {\r\n      s4 <- paste0(\"Since \", ts, \" is between \", max(cv), \" and \", min(cv), \", we fail to reject the null hypothesis.\")\r\n    }\r\n  }\r\n  \r\n  \r\n  list(`Step 1`=s1, \r\n       `Step 2`=paste0(\"Critical Value(s): \", paste0(cv, collapse=\", \")), \r\n       `Step 3`=paste0(\"Test Statistic: t = (x_bar-mu_0)/(s/sqrt(n)) = (\", round(mean(data),ts_dig), \"-\", nh,\")/(\", round(sd(data), ts_dig), \"/sqrt(\", n,\")) = \", ts), \r\n       `Step 4`=s4, \r\n       `Step 5`=\"Translate Step 4 into a context dependent answer to the research question.\")\r\n}\r\n# foo <- c8p_ttest(); foo; c8s_ttest_steps(foo$hidden_data$data, foo$hidden_data$direction, foo$hidden_data$alpha, foo$hidden_data$h0)\r\n\r\n## T Test Plot ----\r\nc8s_ttest_plot <- function(data, direction, alpha, nh=0, cv_dig=2, ts_dig=4, tail_exp=1.1, type=\"z\"){\r\n  gt <- \"T-Distribution for the T-Test\\n(reject in shaded region)\"\r\n  \r\n  # Computing the Test Statistic\r\n  n <- length(data)\r\n  df <- n-1\r\n  ts <- round((mean(data) - nh)/sqrt(var(data)/n), dig=ts_dig)\r\n  \r\n  if(ts < qt(alpha/2, df=df) | ts > qt(1-alpha/2, df=df)){\r\n    lower_bound <- -abs(ts)*tail_exp\r\n    upper_bound <- abs(ts)*tail_exp\r\n    x <- seq(lower_bound, upper_bound, by=.01)\r\n    y <- dt(x, df=df)\r\n  } else{\r\n    lower_bound <- qt(alpha/2, df=df)*tail_exp\r\n    upper_bound <- qt(1-alpha/2, df=df)*tail_exp\r\n    x <- seq(lower_bound, upper_bound, by=.01)\r\n    y <- dt(x, df=df)\r\n  }\r\n  \r\n  #base plot\r\n  if(abs(ts)<0.3){ #if we get too close to the middle, need to extend the plot upwards so the label appears...\r\n    plot(x, y, main=gt, type=\"l\", xlab=\"t\", ylab=\"Density\", ylim=c(0,max(y)*1.1))\r\n  } else {\r\n    plot(x, y, main=gt, type=\"l\", xlab=\"t\", ylab=\"Density\")\r\n  }\r\n  \r\n  #shading area\r\n  if(direction!=\"not equal to\"){\r\n    if(direction==\"greater than\"){\r\n      lower_shade <- qt(1-alpha, df=df)\r\n      upper_shade <- upper_bound\r\n      axis(side=1, at=lower_shade, labels=paste0(\"CV=\", fr(lower_shade,2)), col.axis=\"blue\", mgp=c(0,2,0), col=\"blue\")\r\n    } else if (direction==\"less than\"){\r\n      lower_shade <- lower_bound\r\n      upper_shade <- qt(alpha, df=df)\r\n      axis(side=1, at=upper_shade, labels=paste0(\"CV=\", fr(upper_shade,2)), col.axis=\"blue\", mgp=c(0,2,0), col=\"blue\")\r\n    }\r\n    shade_x <- c(lower_shade, seq(lower_shade, upper_shade, by=.01), upper_shade)\r\n    shade_y <- c(0,dt(seq(lower_shade, upper_shade, by=.01), df=df),0)\r\n    polygon(shade_x, shade_y, col=\"skyblue\")\r\n  } else if (direction==\"not equal to\"){\r\n    lower_shade_l <- lower_bound\r\n    upper_shade_l <- qt(alpha/2, df=df)\r\n    shade_x_l <- c(lower_shade_l, seq(lower_shade_l, upper_shade_l, by=.01), upper_shade_l)\r\n    shade_y_l <- c(0,dt(seq(lower_shade_l, upper_shade_l, by=.01), df=df),0)\r\n    \r\n    lower_shade_u <- qt(1-alpha/2, df=df)\r\n    upper_shade_u <- upper_bound\r\n    shade_x_u <- c(lower_shade_u, seq(lower_shade_u, upper_shade_u, by=.01), upper_shade_u)\r\n    shade_y_u <- c(0,dt(seq(lower_shade_u, upper_shade_u, by=.01), df=df),0)\r\n    \r\n    axis(side=1, at=upper_shade_l, labels=paste0(\"CV=\", fr(upper_shade_l,2)), col.axis=\"blue\", mgp=c(0,2,0), col=\"blue\")\r\n    axis(side=1, at=lower_shade_u, labels=paste0(\"CV=\", fr(lower_shade_u,2)), col.axis=\"blue\", mgp=c(0,2,0), col=\"blue\")\r\n    \r\n    polygon(shade_x_l, shade_y_l, col=\"skyblue\")\r\n    polygon(shade_x_u, shade_y_u, col=\"skyblue\")\r\n  }\r\n  \r\n  #plotting ts\r\n  ts_col <- \"red\"\r\n  segments(x0=ts, y=0, x1=ts, y1=dt(ts, df=df), col=ts_col)\r\n  text(x=ts, y=dt(ts, df=df), labels = paste0(\"TS = \", round(ts,2)), col=ts_col, offset = 1, pos=3)\r\n}\r\n# foo <- c8p_ttest(); foo; c8s_ttest_plot(foo$hidden_data$data, foo$hidden_data$direction, foo$hidden_data$alpha, foo$hidden_data$h0)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# P Test ----\r\n## P Test Steps ----\r\nc8s_ptest_steps <- function(n, x, direction, alpha, nh, cv_dig=2, ts_dig=4){\r\n  p <- x/n\r\n  \r\n  # checking that the null hypothesis is between 0 and 1\r\n  if (!(0 <= nh | nh <= 1))\r\n    stop(\"The variable nh must be between 0 and 1.\")\r\n  \r\n  # Step 1: Stating the Hypothesis\r\n  if(direction==\"less than\"){\r\n    s1 <- paste0(\"H0: p = \", nh, \"   vs   H1: p < \", nh)\r\n  } else if(direction==\"greater than\"){\r\n    s1 <- paste0(\"H0: p = \", nh, \"   vs   H1: p > \", nh)\r\n  } else if(direction==\"not equal to\"){\r\n    s1 <- paste0(\"H0: p = \", nh, \"   vs   H1: p != \", nh)\r\n  }\r\n  \r\n  # Step 2: Finding the Critical Value\r\n  if(direction==\"less than\"){\r\n    cv <- round(qnorm(alpha), dig=cv_dig)\r\n  } else if(direction==\"greater than\"){\r\n    cv <- round(qnorm(1-alpha), dig=cv_dig)\r\n  } else if(direction==\"not equal to\"){\r\n    cv <- round(qnorm(c(alpha/2, 1-alpha/2)), dig=cv_dig)\r\n  }\r\n  \r\n  # Step 3: Computing the Test Statistic\r\n  ts <- round((p - nh)/sqrt(nh*(1-nh)/n), dig=ts_dig)\r\n  \r\n  # Step 4: Make the Decision\r\n  if(direction==\"less than\"){\r\n    if(ts<cv){\r\n      s4 <- paste0(\"Since \", ts, \" is less than \", cv, \", we reject the null hypothesis.\")\r\n    } else {\r\n      s4 <- paste0(\"Since \", ts, \" is not less than \", cv, \", we fail to reject the null hypothesis.\")\r\n    }\r\n    \r\n  } else if(direction==\"greater than\"){\r\n    if(ts>cv){\r\n      s4 <- paste0(\"Since \", ts, \" is greater than \", cv, \", we reject the null hypothesis.\")\r\n    } else {\r\n      s4 <- paste0(\"Since \", ts, \" is not greater than \", cv, \", we fail to reject the null hypothesis.\")\r\n    }\r\n    \r\n  } else if(direction==\"not equal to\"){\r\n    if(ts>max(cv)){\r\n      s4 <- paste0(\"Since \", ts, \" is greater than \", max(cv), \", we reject the null hypothesis.\")\r\n    } else if (ts<min(cv)){\r\n      s4 <- paste0(\"Since \", ts, \" is less than \", min(cv), \", we reject the null hypothesis.\")\r\n    } else {\r\n      s4 <- paste0(\"Since \", ts, \" is between \", max(cv), \" and \", min(cv), \", we fail to reject the null hypothesis.\")\r\n    }\r\n  }\r\n  \r\n  list(`Step 1`=s1, \r\n       `Step 2`=paste0(\"Critical Value(s): \", paste0(cv, collapse=\", \")), \r\n       `Step 3`=paste0(\"Test Statistic: z = (p-p_0)/(sqrt(p0*(1-p0)/n)) = (\", fr(p,4), \"-\", nh,\")/(sqrt(\", nh,\"*(1-\", nh,\")/\", n, \")) = \", ts), \r\n       `Step 4`=s4, \r\n       `Step 5`=\"Translate Step 4 into a context dependent answer to the research question.\")\r\n}\r\n# foo <- c8p_ptest(); foo; c8s_ptest_steps(foo$hidden_data$n, foo$hidden_data$x, foo$hidden_data$direction, foo$hidden_data$alpha, foo$hidden_data$p0)\r\n\r\n## P Test Plot ----\r\nc8s_ptest_plot <- function(n, x, direction, alpha, nh, cv_dig=2, ts_dig=4, tail_exp=1.1, type=\"z\"){\r\n  gt <- \"Z-Distribution for the Test of Proportions\\n(reject in shaded region)\"\r\n  \r\n  # Computing the Test Statistic\r\n  p <- x/n\r\n  ts <- round((p - nh)/sqrt(nh*(1-nh)/n), dig=ts_dig)\r\n  \r\n  if(ts < qnorm(alpha/2) | ts > qnorm(1-alpha/2)){\r\n    lower_bound <- -abs(ts)*tail_exp\r\n    upper_bound <- abs(ts)*tail_exp\r\n    x <- seq(lower_bound, upper_bound, by=.01)\r\n    y <- dnorm(x)\r\n  } else{\r\n    lower_bound <- qnorm(alpha/2)*tail_exp\r\n    upper_bound <- qnorm(1-alpha/2)*tail_exp\r\n    x <- seq(lower_bound, upper_bound, by=.01)\r\n    y <- dnorm(x)\r\n  }\r\n  \r\n  #base plot\r\n  if(abs(ts)<0.3){ #if we get too close to the middle, need to extend the plot upwards so the label appears...\r\n    plot(x, y, main=gt, type=\"l\", xlab=\"t\", ylab=\"Density\", ylim=c(0,max(y)*1.1))\r\n  } else {\r\n    plot(x, y, main=gt, type=\"l\", xlab=\"t\", ylab=\"Density\")\r\n  }\r\n  \r\n  #shading area\r\n  if(direction!=\"not equal to\"){\r\n    if(direction==\"greater than\"){\r\n      lower_shade <- qnorm(1-alpha)\r\n      upper_shade <- upper_bound\r\n      axis(side=1, at=lower_shade, labels=paste0(\"CV=\", fr(lower_shade,2)), col.axis=\"blue\", mgp=c(0,2,0), col=\"blue\")\r\n    } else if (direction==\"less than\"){\r\n      lower_shade <- lower_bound\r\n      upper_shade <- qnorm(alpha)\r\n      axis(side=1, at=upper_shade, labels=paste0(\"CV=\", fr(upper_shade,2)), col.axis=\"blue\", mgp=c(0,2,0), col=\"blue\")\r\n    }\r\n    shade_x <- c(lower_shade, seq(lower_shade, upper_shade, by=.01), upper_shade)\r\n    shade_y <- c(0,dnorm(seq(lower_shade, upper_shade, by=.01)),0)\r\n    polygon(shade_x, shade_y, col=\"skyblue\")\r\n  } else if (direction==\"not equal to\"){\r\n    lower_shade_l <- lower_bound\r\n    upper_shade_l <- qnorm(alpha/2)\r\n    shade_x_l <- c(lower_shade_l, seq(lower_shade_l, upper_shade_l, by=.01), upper_shade_l)\r\n    shade_y_l <- c(0,dnorm(seq(lower_shade_l, upper_shade_l, by=.01)),0)\r\n    \r\n    lower_shade_u <- qnorm(1-alpha/2)\r\n    upper_shade_u <- upper_bound\r\n    shade_x_u <- c(lower_shade_u, seq(lower_shade_u, upper_shade_u, by=.01), upper_shade_u)\r\n    shade_y_u <- c(0,dnorm(seq(lower_shade_u, upper_shade_u, by=.01)),0)\r\n    \r\n    axis(side=1, at=upper_shade_l, labels=paste0(\"CV=\", fr(upper_shade_l,2)), col.axis=\"blue\", mgp=c(0,2,0), col=\"blue\")\r\n    axis(side=1, at=lower_shade_u, labels=paste0(\"CV=\", fr(lower_shade_u,2)), col.axis=\"blue\", mgp=c(0,2,0), col=\"blue\")\r\n    \r\n    polygon(shade_x_l, shade_y_l, col=\"skyblue\")\r\n    polygon(shade_x_u, shade_y_u, col=\"skyblue\")\r\n  }\r\n  \r\n  #plotting ts\r\n  ts_col <- \"red\"\r\n  segments(x0=ts, y=0, x1=ts, y1=dnorm(ts), col=ts_col)\r\n  text(x=ts, y=dnorm(ts), labels = paste0(\"TS = \", round(ts,2)), col=ts_col, offset = 1, pos=3)\r\n}\r\n# foo <- c8p_ptest(); foo; c8s_ptest_plot(foo$hidden_data$n, foo$hidden_data$x, foo$hidden_data$direction, foo$hidden_data$alpha, foo$hidden_data$p0)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Complete Solution Function ----\r\n## Steps Solution Function ----\r\nc8s_steps <- function(prob_obj){\r\n  prob_type <- prob_obj$hidden_data$prob_type\r\n  hdat <- prob_obj$hidden_data\r\n  \r\n  if(prob_type == \"ztest\"){\r\n    out <- c8s_ztest_steps(data=prob_obj$data, sigma=hdat$sigma, direction=hdat$direction, alpha=hdat$alpha, nh=hdat$h0, cv_dig=2, ts_dig=4)\r\n  } else if (prob_type == \"ttest\"){\r\n    out <- c8s_ttest_steps(data=prob_obj$data, direction=hdat$direction, alpha=hdat$alpha, nh=hdat$h0, cv_dig=2, ts_dig=4)\r\n  } else if (prob_type == \"ptest\"){\r\n    out <- c8s_ptest_steps(n=hdat$n, x=hdat$x, direction=hdat$direction, alpha=hdat$alpha, nh=hdat$p0)\r\n  } else {\r\n    stop(\"Problem type currently not supported in c8s.\")\r\n  }\r\n  out\r\n}\r\n# foo <- c8p(); foo; c8s_steps(foo)\r\n\r\n## Plot Solution Function ----\r\nc8s_plot <- function(prob_obj){\r\n  prob_type <- prob_obj$hidden_data$prob_type\r\n  hdat <- prob_obj$hidden_data\r\n  \r\n  if(prob_type == \"ztest\"){\r\n    c8s_ztest_plot(data=prob_obj$data, sigma=hdat$sigma, direction=hdat$direction, alpha=hdat$alpha, nh=hdat$h0, cv_dig=2, ts_dig=4)\r\n  } else if (prob_type == \"ttest\"){\r\n    c8s_ttest_plot(data=prob_obj$data, direction=hdat$direction, alpha=hdat$alpha, nh=hdat$h0, cv_dig=2, ts_dig=4)\r\n  } else if (prob_type == \"ptest\"){\r\n    c8s_ptest_plot(n=hdat$n, x=hdat$x, direction=hdat$direction, alpha=hdat$alpha, nh=hdat$p0)\r\n  } else {\r\n    stop(\"Problem type currently not supported in c8s.\")\r\n  }\r\n}\r\n# foo <- c8p(); foo; c8s_plot(foo)\r\n\r\n\r\n","type":"text"},{"name":"runMe.R","content":"list.of.packages <- c(\"htmltools\", \"shiny\", \"toOrdinal\", \"qboxplot\", \"DT\", \"R.utils\", \"aplpack\", \"xtable\")\r\nnew.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,\"Package\"])]\r\nif(length(new.packages)) install.packages(new.packages, dependencies=TRUE)\r\nshiny::runGitHub(\"basic-stats-homework-app\", username=\"drfloren\", launch.browser=TRUE)\r\n","type":"text"}]
